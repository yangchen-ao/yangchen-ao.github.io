<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="https://xiaowog.top/atom.xml" rel="self"/>
  
  <link href="https://xiaowog.top/"/>
  <updated>2022-04-24T09:55:15.361Z</updated>
  <id>https://xiaowog.top/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>闭包和装饰器</title>
    <link href="https://xiaowog.top/2022/04/24/%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://xiaowog.top/2022/04/24/%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2022-04-24T09:55:15.000Z</published>
    <updated>2022-04-24T09:55:15.361Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://xiaowog.top/2022/04/23/04.23%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://xiaowog.top/2022/04/23/04.23%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-04-23T06:24:53.000Z</published>
    <updated>2022-04-24T09:26:04.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>类(class)：具有相同属性和方法的对象的集合。它定义了该集合没个对象所共有的属性和方法。通过关键字 class 定义，类名的首字母一般要大写。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 类名:</span><br><span class="line">类体</span><br></pre></td></tr></table></figure><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><p>创建一个类的实例（类的具体对象）的过程叫做实例化。</p><p>当实例化一个对象时，类会调用构造方法<code>__init__()</code>来初始化当前对象的相关属性，该方法无返回值。</p><p>当类对象被创建后，可以通过<code>对象名.属性名</code>来引用该属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student:</span><br><span class="line">def __init__(self,name,age,score):</span><br><span class="line">self.age = age</span><br><span class="line">self.name = name</span><br><span class="line">self.score = score</span><br><span class="line">s = Student(&#x27;Lusy&#x27;,18,79)</span><br><span class="line">print(s)</span><br><span class="line">print(s.age)</span><br></pre></td></tr></table></figure><h5 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__方法"></a><code>__init__方法</code></h5><p>初始化对象，在创建对象时调用该方法，如果不定义<code>__init__</code>方法，系统会提供一个默认的<code>__init__</code>方法。如果定义了带参的<code>__init__</code>方法，系统不创建默认的<code>__init__</code>方法。 </p><p>同样，构造方法也可以有其他参数，参数通过实例化类时被传入。</p><p><strong>注意</strong>：self 必须为构造函数的第一个参数</p><h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><p>每一个类都具有自己的属性和方法。属性和方法是面向对象程序设计所独有的概念。属性是类所封装的数据，而方法则是类对数据进行的操作。</p><h5 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h5><p>通过<code>self</code>修饰的一个变量（或者说属性），一般定义在<code>__init__()</code>方法中。可以在类内通过<code>self.实例属性名</code>来访问，在类外创建实例对象后可以通过实例对象访问，如上面例子中的<code>s.gae</code> 。</p><h5 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h5><p>直接在类中定义的属性就是类属性，实际上就是类内部的变量。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 类名： </span><br><span class="line">    类变量名= 初始值 </span><br></pre></td></tr></table></figure><p>在此介绍两种属性，公有属性和私有属性</p><ul><li>公有属性<br>在类内和类外都能调用的属性，称为类的公有属性。</li><li>私有属性<br><code>__private_attrs</code>：两个下划线开头，声明该属性私有，不能在类的外部被直接访问。在类内部中通过<code>self.__private_attrs</code>访问。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student: </span><br><span class="line">    company = &quot;WI&quot; # 公有属性</span><br><span class="line">__sum_age = 0 # 私有属性</span><br><span class="line">    </span><br><span class="line">    def __init__(self, name, age, score): </span><br><span class="line">        self.name = name # 实例属性 </span><br><span class="line">        self.score = score</span><br><span class="line">        self.age = age</span><br><span class="line">        Student.__sum_age = Student.__sum_age + age </span><br><span class="line">    def say_score(self): # 实例方法</span><br><span class="line">        print(&quot;我的公司是：&quot;, Student.company)</span><br><span class="line">print(self.name, &#x27;的分数是：&#x27;, self.score) </span><br><span class="line">        </span><br><span class="line">s1 = Student(&#x27;武松&#x27;, 18, 80)</span><br><span class="line">s1.say_score()</span><br></pre></td></tr></table></figure><h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p>在类的内部，使用 def 关键字来定义的方法叫做实例方法。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def 方法名(self [, 形参列表])： </span><br><span class="line">    方法体 </span><br></pre></td></tr></table></figure><p>在类外，创建实例对象后，可通过<code>对象.方法名([实参列表])</code>的方法调用，如上面例子中的<code>s1.say_score()</code>。</p><p>注意：</p><ul><li>定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。</li><li>调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。</li></ul><h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><p>类方法通过装饰器@classmethod 来定义，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@classmethod </span><br><span class="line">def 类方法名(cls [，形参列表]) ： </span><br><span class="line">    函数体 </span><br></pre></td></tr></table></figure><p>在此介绍两种方法私有方法和公有方法，当然之后还会介绍内置方法。</p><ul><li><p>私有方法<br><code>__private_method</code>：两个下划线开头，声明该方法私有，只能在类的内部调用 ，不能在类的外部直接调用，<code>self.__private_methods</code>。</p></li><li><p>公有方法</p><p>在类内和类外都能调用的方法，称为类的公有方法。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Novel:</span><br><span class="line">    name = &quot;斗罗大陆&quot; </span><br><span class="line">    __price = 33.33</span><br><span class="line">    </span><br><span class="line">    def __init__(self,n):   # 实例方法</span><br><span class="line">        self.name = &quot;酒神&quot;  # 实例属性</span><br><span class="line">        self.__number = n   # 私有实例属性</span><br><span class="line">        Novel.__price += 10</span><br><span class="line"></span><br><span class="line">    def show(self):  # 普通实例方法</span><br><span class="line">        print(&quot;name:名字&quot;,self.name)</span><br><span class="line">        print(&#x27;self.__number:数量&#x27;, self.__number)</span><br><span class="line">        print(&#x27;Root.__price:价格&#x27;, Novel.__price)</span><br><span class="line"></span><br><span class="line">    @classmethod  # 类方法</span><br><span class="line">    def name_2(cls):</span><br><span class="line">        cls.name = &quot;神澜奇域&quot;</span><br><span class="line">        print(cls.__price)</span><br><span class="line">        print(cls.name)</span><br><span class="line"></span><br><span class="line"># 实例化对象</span><br><span class="line">n1 = Novel(21)</span><br><span class="line"># 两种方式调用实例方法</span><br><span class="line">Novel.show(n1)</span><br><span class="line">n1.show()</span><br><span class="line"># 两种方式调用类方法</span><br><span class="line">n1.name_2()</span><br><span class="line">Novel.name_2()</span><br></pre></td></tr></table></figure><h5 id="常用的内置方法"><a href="#常用的内置方法" class="headerlink" title="常用的内置方法"></a>常用的内置方法</h5><table><thead><tr><th><code>内置方法</code></th><th><code>说明</code></th></tr></thead><tbody><tr><td><code>__init__(self……)</code></td><td><code>初始化对象，在创建对象时调用</code></td></tr><tr><td><code>__del__(self)</code></td><td><code>释放对象，在对象被删除前调用</code></td></tr><tr><td><code>__new__(self,……)</code></td><td><code>实例的生成操作</code></td></tr><tr><td><code>__str__(self)</code></td><td><code>在使用print语句打印该类时被调用</code></td></tr><tr><td><code>__call__(self)</code></td><td><code>使该类的实例变成一个可调用的实例对象</code></td></tr></tbody></table><p>下面为一些介绍</p><ul><li><p><code>__del__方法</code>(析构函数) </p><p>析构函数用于释放对象占用的资源。由于 Python 中定义了<code>__del__()</code>的实例将无法被 Python 循环垃圾收集器（gc）收集，所以建议只有在需要时才定义<code>__del__()</code>。</p></li><li><p><code>__str__方法</code></p><p>如果希望使用 print 输出对象的描述信息，且能够打印自定义内容，可以使用 <code>__str __</code>内置方法。当使用 <code>__str __</code>内置方法时，print打印类将会输出对象的描述信息。</p></li><li><p><code>__call__()方法</code></p><p>定义了<code>__call__</code>方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#析构函数 </span><br><span class="line">class Person: </span><br><span class="line">    def __del__(self): </span><br><span class="line">        print(&quot;销毁对象：&#123;0&#125;&quot;.format(self)) </span><br><span class="line">p1 = Person() </span><br><span class="line">p2 = Person() </span><br><span class="line">del p2 </span><br><span class="line">print(&quot;程序结束&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># __str__()方法</span><br><span class="line">class Student: </span><br><span class="line">    def __init__(self,name,score): </span><br><span class="line">        self.name = name # 实例属性</span><br><span class="line">        self.score = score </span><br><span class="line">    def __str__(self): </span><br><span class="line">        return &#x27;&#123;0&#125;的分数是&#123;1&#125;&#x27;.format(self.name,self.score) </span><br><span class="line">        # 返回一个字符串 </span><br><span class="line">s1 = Student(&#x27;张三&#x27;,80)  </span><br><span class="line"># s1 是实例对象，自动调用__init__()方法 </span><br><span class="line">print(s1)     </span><br><span class="line"># 输出 s1 对象时候，调用__str__()方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试__call__，可调用对象 </span><br><span class="line">class SalaryAccount: </span><br><span class="line">    &#x27;&#x27;&#x27;工资计算类&#x27;&#x27;&#x27; </span><br><span class="line">    def __call__(self, salary): </span><br><span class="line">        yearSalary = salary*12 </span><br><span class="line">        daySalary = salary//30 </span><br><span class="line">        hourSalary = daySalary//8 </span><br><span class="line">        return dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary,hourSalary=hourSalary )</span><br><span class="line"></span><br><span class="line">s = SalaryAccount() </span><br><span class="line">print(s(5000)) # 可以像调用函数一样调用对象的__call__方法</span><br></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>假如从父类继承的方法不能够满足子类的需求，也可以在子类中对其进行重新定义，这个过程叫做方法的重写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person: </span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name </span><br><span class="line">        self.age = age </span><br><span class="line">    def say_age(self): </span><br><span class="line">        print(&quot;年龄：&quot;,self.age) </span><br><span class="line">    def say_name(self): </span><br><span class="line">        print(&quot;姓名：&quot;,self.name) </span><br><span class="line"></span><br><span class="line">class Student(Person): </span><br><span class="line">    def __init__(self,name,age,score): </span><br><span class="line">        self.score = score </span><br><span class="line">        Person.__init__(self,name,age) #构造函数中包含调用父类构造函数 </span><br><span class="line">    def say_score(self): </span><br><span class="line">        print(&quot;分数是：&quot;,self.score) </span><br><span class="line">    #重写父类的方法 </span><br><span class="line">    def say_name(self): </span><br><span class="line">        print(&quot;报告老师，我是&quot;,self.name) </span><br><span class="line"></span><br><span class="line">s1 = Student(&quot;张三&quot;,15,85) </span><br><span class="line">s1.say_score() </span><br><span class="line">s1.say_name() </span><br><span class="line">s1.say_age()</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>python 也支持运算符重载，可以对类的专有方法进行重载，例如：</p><table><thead><tr><th align="center">运算符</th><th>特殊方法</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td><code>__add__</code></td><td>加法</td></tr><tr><td align="center"><code>-</code></td><td><code>__sub__</code></td><td>减法</td></tr><tr><td align="center"><code>&lt;,&lt;=,==</code></td><td><code>__lt__,__le__,__eq__</code></td><td>比较运算符</td></tr><tr><td align="center"><code>&gt;,&gt;=,!=</code></td><td><code>__gt__,__ge__,__ne__</code></td><td></td></tr><tr><td align="center">`</td><td>,^,&amp;`</td><td><code>__or__,__xor__,__and__</code></td></tr><tr><td align="center"><code>&gt;&gt;,&lt;&lt;</code></td><td><code>__rshift__,__lshift__</code></td><td>右移，左移</td></tr><tr><td align="center"><code>*,/,%,//</code></td><td><code>__mul__,__truediv__,__mod__,__floordiv__</code></td><td>乘，浮点除，模运算，整数除</td></tr><tr><td align="center"><code>**</code></td><td><code>__pow__</code></td><td>指数运算</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 测试运算符的重载 </span><br><span class="line">class Objections:</span><br><span class="line">    def __init__(self,name): </span><br><span class="line">        self.name = name</span><br><span class="line"> def __add__(self, other): </span><br><span class="line">        if isinstance(other,Person): </span><br><span class="line">            return &quot;&#123;0&#125;--&#123;1&#125;&quot;.format(self.name,other.name) </span><br><span class="line">        else:</span><br><span class="line">            return &quot;不是同类对象，不能相加&quot;</span><br><span class="line">        </span><br><span class="line">    def __mul__(self, other): </span><br><span class="line">        if isinstance(other,int): </span><br><span class="line">            return self.name*other </span><br><span class="line">        else:</span><br><span class="line">            return &quot;不是同类对象，不能相乘&quot; </span><br><span class="line"></span><br><span class="line">p1 = Objections(&quot;武汉&quot;) </span><br><span class="line">p2 = Objections(&quot;学院&quot;) </span><br><span class="line">x = p1 + p2 #调用 __add__()方法 </span><br><span class="line">print(x) </span><br><span class="line">print(p1*3) #调用__mul__()方法</span><br></pre></td></tr></table></figure><h3 id="面向对象的特折"><a href="#面向对象的特折" class="headerlink" title="面向对象的特折"></a>面向对象的特折</h3><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><p>继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。</p><p>已有的类，称为“父类或者基类”，新的类，称为“子类或者派生类”。继承也允许把一个派生类的对象作为一个基类对象对待。继承基类所具有的属性和方法派生类也具有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 派生类类名(基类):</span><br><span class="line">类体</span><br></pre></td></tr></table></figure><p>如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父类。如果在子类中需要父类的构造方法就需要通过<code>父类名.__init__(self, 参数列表)</code> 来显式的调用父类的构造方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person: </span><br><span class="line">    def __init__(self,name,age): </span><br><span class="line">        self.name = name </span><br><span class="line">        self.__age = age </span><br><span class="line">    </span><br><span class="line">    def say_age(self): </span><br><span class="line">        print(self.name,&quot;的年龄是：&quot;,self.__age) </span><br><span class="line"></span><br><span class="line">class Student(Person): </span><br><span class="line">    def __init__(self,name,age,score): </span><br><span class="line">        self.score = score </span><br><span class="line">        #子类并不会自动调用父类的__init__()构造方法，需要显式的调用 </span><br><span class="line">        Person.__init__(self,name,age) </span><br><span class="line">        </span><br><span class="line">s1 = Student(&quot;张三&quot;,15,85) </span><br><span class="line">s1.say_age()</span><br></pre></td></tr></table></figure><h5 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h5><p>Python 支持多重继承， 一个子类可以有多个“直接父类”。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 子类类名(父类 1,父类 2,父类 3…)：</span><br><span class="line">类体</span><br></pre></td></tr></table></figure><p>圆括号中父类的顺序需要注意，如果父类中有相同的方法名，当方法未在子类中找到时，将会从左到右查找父类中是否包含该方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#多重继承 </span><br><span class="line">class A: </span><br><span class="line">    def aa(self): </span><br><span class="line">        print(&quot;aa&quot;) </span><br><span class="line">        </span><br><span class="line">class B: </span><br><span class="line">    def bb(self): </span><br><span class="line">        print(&quot;bb&quot;) </span><br><span class="line">        </span><br><span class="line">class C(B,A): </span><br><span class="line">    def cc(self): </span><br><span class="line">        print(&quot;cc&quot;) </span><br><span class="line">        </span><br><span class="line">c = C()</span><br><span class="line">c.cc() </span><br><span class="line">c.bb() </span><br><span class="line">c.aa()</span><br></pre></td></tr></table></figure><h5 id="super-函数"><a href="#super-函数" class="headerlink" title="super()函数"></a>super()函数</h5><p>super()函数时调用父类的一个方法，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用父类的属性 super().name</span><br><span class="line">调用父类的方法 super().name()</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#super() </span><br><span class="line">class A: </span><br><span class="line">    def say(self): </span><br><span class="line">        print(&quot;say AAA&quot;) </span><br><span class="line">        </span><br><span class="line">class B(A): </span><br><span class="line">    def say(self): </span><br><span class="line">        A.say(self) #调用父类的 say 方法 </span><br><span class="line">        super().say() #通过 super()调用父类的方法 </span><br><span class="line">        print(&quot;say BBB&quot;)</span><br><span class="line">    </span><br><span class="line">b = B() </span><br><span class="line">b.say()</span><br></pre></td></tr></table></figure><h5 id="mro-方法"><a href="#mro-方法" class="headerlink" title="mro()方法"></a>mro()方法</h5><p>MRO（Method Resolution Order）指方法解析顺序。Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将“从左向右”按顺序搜索。可以通过mro()方法获得“类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。</p><p>MRO()方法的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#多重继承 </span><br><span class="line">class A: </span><br><span class="line">    def aa(self): </span><br><span class="line">        print(&quot;aa&quot;) </span><br><span class="line">    def say(self): </span><br><span class="line">        print(&quot;say AAA!&quot;) </span><br><span class="line"></span><br><span class="line">class B: </span><br><span class="line">    def bb(self): </span><br><span class="line">        print(&quot;bb&quot;) </span><br><span class="line">    def say(self): </span><br><span class="line">        print(&quot;say BBB!&quot;) </span><br><span class="line">        </span><br><span class="line">class C(B,A): </span><br><span class="line">    def cc(self): </span><br><span class="line">        print(&quot;cc&quot;) </span><br><span class="line">        </span><br><span class="line">c = C()</span><br><span class="line">print(C.mro()) #打印类的层次结构 </span><br><span class="line">#解释器寻找方法是“从左到右”的方式寻找，此时会执行 B 类中的 say() </span><br><span class="line">c.say()</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态指的是同一个方法调用，由于对象不同可能会有不同的行为。</p><p>多态的要点：</p><ul><li>多态是方法的多态，不是属性的多态（多态与属性无关）。</li><li>多态的存的必要条件：继承，方法重写。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#多态 </span><br><span class="line">class Animal: </span><br><span class="line">    def shout(self): </span><br><span class="line">        print(&quot;动物叫了一声&quot;) </span><br><span class="line">        </span><br><span class="line">class Dog(Animal): </span><br><span class="line">    def shout(self): </span><br><span class="line">        print(&quot;小狗，汪汪汪&quot;) </span><br><span class="line">        </span><br><span class="line">class Cat(Animal): </span><br><span class="line">    def shout(self): </span><br><span class="line">        print(&quot;小猫，喵喵喵&quot;) </span><br><span class="line">        </span><br><span class="line">def animalShout(a): </span><br><span class="line">    if isinstance(a,Animal): </span><br><span class="line">        a.shout() #传入的对象不同，shout 方法对应的实际行为也不同。 </span><br><span class="line">        </span><br><span class="line">animalShout(Dog()) </span><br><span class="line">animalShout(Cat())</span><br></pre></td></tr></table></figure><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>　封装就是指隐藏对象的属性和实现的细节，仅对外公开提供简单的接口。外部不能访问，内部可以正常使用。</p><p>好处：</p><ol><li><p>为了保护数据的安全 </p><ol start="2"><li>对外隐藏实现的细节，为了隔离复杂度</li></ol></li></ol><p>实现，如私有属性和私有方法等。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="检测继承关系"><a href="#检测继承关系" class="headerlink" title="检测继承关系"></a>检测继承关系</h4><p>在很多场景中，需要知道一个类 A 是否是从另外一个类 B 继承，这种校验主要是为了调用 B 类中的成员(方法和属性)。这时可以使用 issubclass 函数来判断B 是否是 A 的父类。语法格式如下：<code>issubclass(sub,sup)</code> </p><p>其中，第 1 个参数是子类、第 2 个参数是父类。如果第 1 个参数指定的类与第 2 个参数指定的类确实是继承关系，那么该函数返回 True，否则返回 False。</p><h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h4><p>isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。isinstance() 方法的语法如下：<code>isinstance(object, classinfo)</code></p><p>其中第一个参数（object）为实例对象，第二个参数（type）可以是直接或间接类名、 基本类型或者由它们组成的元组。其返回值为布尔型（True or Flase）。</p><p><strong>注意：</strong></p><ul><li>type() 不会认为子类是一种父类类型，不考虑继承关系。</li><li>isinstance() 会认为子类是一种父类类型，考虑继承关系。如果要判断两个类型是否相同推荐使用 isinstance()。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h3&gt;&lt;h4 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; title=&quot;类定义&quot;&gt;&lt;/a&gt;类定</summary>
      
    
    
    
    
    <category term="python基础" scheme="https://xiaowog.top/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python细节</title>
    <link href="https://xiaowog.top/2022/04/16/04.16-python%E7%BB%86%E8%8A%82/"/>
    <id>https://xiaowog.top/2022/04/16/04.16-python%E7%BB%86%E8%8A%82/</id>
    <published>2022-04-16T05:26:43.000Z</published>
    <updated>2022-07-20T07:16:52.122Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>字符串里的元素是不可改变</li><li>字符串的加法是创建一个新字符串，而不是在原字符串后添加</li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li>列表复制方法：<code>b = list（a）</code>，无论a是否是列表，list函数都会进行复制产生一个新列表；<code>b = a.copy</code> 对列表a其进行显式复制；<strong>列表切片</strong>返回的是复制；列表的加法也是复制</li><li>如何叠加列表：因为列表的加法是进行复制创建新列表，所以推荐extend()进行原地叠加</li></ul><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul><li>元组排序：用sorted函数实现该功能，不过得到的是一个列表，而不是元组</li><li>元组创建：（）为空元组，而（42）为整数，ps : 小括号可以省略，但逗号不能省略</li><li>元组的元素可以是可变元素，即可以为列表，集合，字典等</li><li>元组时有序的，但集合是无序</li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>集合排序：集合虽然是无序的，但可以通过sorted函数得到一个已排序的列表</li><li>set.update()把序列拆分之后，再添加进去</li><li>set.discard(元素)，可以删除指定元素，元素不存在时不会报错</li><li>集合的元素不能是<strong>可变类型数据</strong>，所以只能是整数，浮点数，复数，字符串类型，元组类型等</li></ul><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ul><li>dict.fromkeys(键，值)方法创建值为空的字典，所有键的值都为改值</li><li>字典的键必须是不可变对象，不能为列表、字典、集合</li><li>字典用sorted函数排序时，会得到一个由键组成的排序列表</li><li>pop和popitem删除指定的键值对，并返回值对象</li><li>update 方法可以用一个字典中的元素更新另外一个字典。该方法接收一个参数。该参数表示用作更新数据的字典数据源。如果 key 有重复，则直接覆盖，否则加入key-value</li><li>访问问题：因为通过键来访问值，当键不存在时会抛出异常，所以推荐使用get方法来获取值，不存再时返回None或者默认值</li><li>当for遍历字典时候，（for i in a:）i是字典a的键</li></ul><h4 id="int函数"><a href="#int函数" class="headerlink" title="int函数"></a>int函数</h4><p>int中的字符串可以为’     2’，’     2      ‘或者’\t 2 \n’，都会被转换成数字2，不用刻意去删这些空白字符。</p><h4 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h4><p><strong>type(type(4.0))  为type类型</strong> class type</p><h4 id="集合不能是可变类型数据的原因"><a href="#集合不能是可变类型数据的原因" class="headerlink" title="集合不能是可变类型数据的原因"></a>集合不能是可变类型数据的原因</h4><p>由于集合的唯一性，所以集合不含有可变类型数据。</p><p>如<code>s = &#123;[12,23,34],[13,23,34],13,a&#125;</code>，当将第二个列表中的第一个元素修改为12的时候时，集合将会出错。</p><h4 id="文档路径-反斜杠处理"><a href="#文档路径-反斜杠处理" class="headerlink" title="文档路径-反斜杠处理"></a>文档路径-反斜杠处理</h4><ul><li>通过r进行转义，<code>r&#39;C:\User&#39;</code></li><li>通过反斜杠进行对自身的转义，<code>‘\\’</code></li><li>将反斜杠转换成<code>&#39;/&#39;</code></li></ul><h4 id="0-1-0-2-0-3返回为False"><a href="#0-1-0-2-0-3返回为False" class="headerlink" title="0.1+0.2 == 0.3返回为False"></a>0.1+0.2 == 0.3返回为False</h4><p>原因是浮点数精确度的问题，不是<code>==</code>的问题，浮点数本身就是不准确的。</p><p>暂时只发现这个是这样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;字符串里的元素是不可改变&lt;/li&gt;
&lt;li&gt;字符串的加法是创建一个新字符串，而不是在原字符串后添加&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    
    <category term="python坑" scheme="https://xiaowog.top/tags/python%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://xiaowog.top/2022/03/23/03.23-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://xiaowog.top/2022/03/23/03.23-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-03-23T01:32:36.000Z</published>
    <updated>2022-07-20T07:15:58.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>数组为有序数组，同时数组中应无重复元素</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>推荐观看B站视频—-<a class="link" href="https://b23.tv/NBK6av1">点这<i class="fas fa-external-link-alt"></i></a>。</p><p>总结（做题步骤）：</p><ol><li><p>画分红蓝区，即找出红蓝区的界限（题目给出或者自己设定）</p></li><li><p>确定返回红区边界还是蓝区边界</p></li><li><p>套用模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = -1,r = n</span><br><span class="line">while l+1 != r:</span><br><span class="line">m = [(l+r)/2]</span><br><span class="line">if isBule(m):</span><br><span class="line">l = m</span><br><span class="line">else:</span><br><span class="line">r = m</span><br><span class="line">return l or r</span><br></pre></td></tr></table></figure></li><li><p>后续处理细节</p></li></ol><p>注：l,r的指针要确保在有序序列之外，对于长度为n的来说，<code>l = -1</code>，<code>r = n</code>。</p><p>练手题目：</p><ul><li>leetcode704—-<a class="link" href="https://leetcode-cn.com/problems/binary-search/">二分查找<i class="fas fa-external-link-alt"></i></a></li><li>leetcode278—-<a class="link" href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本<i class="fas fa-external-link-alt"></i></a></li><li>leetcode35—-<a class="link" href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置<i class="fas fa-external-link-alt"></i></a></li><li>leetcode367—-<a class="link" href="https://leetcode-cn.com/problems/valid-perfect-square/">有效的完全平方数<i class="fas fa-external-link-alt"></i></a></li><li>leetcode1385—-<a class="link" href="https://leetcode-cn.com/problems/find-the-distance-value-between-two-arrays/">两个数组间的距离值<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="高阶函数（python）"><a href="#高阶函数（python）" class="headerlink" title="高阶函数（python）"></a>高阶函数（python）</h4><p>bisect模块使用了基本的二分（bisection）算法。</p><p>其定义了以下函数：</p><ul><li><p>bisect.bisect_left(a, x, <em>lo=0</em>, <em>hi=len(a)</em>)</p><p>在有序数组a（默认整个数组，lo是指需查找数组的左端（含），hi是指需查找数组的右端（不含））中找到x合适的插入位置点以维持有序。如果 <em>x</em> 已经在 <em>a</em> 里存在，那么插入点会在已存在元素之前（也就是左边）。</p><p>返回结果为x插入的位置，这个位置把数组分成两个部分。</p></li></ul><ul><li><p>bisect.bisect_right(a, x, <em>lo=0</em>, <em>hi=len(a)</em>)</p></li><li><p>bisect.bisect(a, x, <em>lo=0</em>, <em>hi=len(a)</em>)</p><p>类似于 bisect_right()，返回的插入点是 <em>a</em> 中已存在元素 x 的右侧。</p></li><li><p>bisect.insort_left(a, x, <em>lo=0</em>, <em>hi=len(a)</em>)</p><p>将 x 插入到一个有序序列 <em>a</em> 里，并维持其有序，等同于a.insert(bisect.bisect_left(a, x, lo, hi), x)。</p><p>注意：搜索时间复杂度是 O(log n) 的，插入却是 O(n) 的。</p></li><li><p>bisect.insort_right(a, x, <em>lo=0</em>, <em>hi=len(a)</em>)</p></li><li><p>bisect.insort(a, x, <em>lo=0</em>, <em>hi=len(a)</em>)</p><p>类似于 insort_right()，但是把 x 插入到 a 中已存在元素 x 的右侧。</p><p>​</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h3&gt;&lt;h4 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://xiaowog.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>pandas基础（1）-Series数据类型</title>
    <link href="https://xiaowog.top/2022/03/17/pandas%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89-Series%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xiaowog.top/2022/03/17/pandas%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89-Series%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-03-17T01:23:46.000Z</published>
    <updated>2022-03-17T07:16:45.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas库"><a href="#pandas库" class="headerlink" title="pandas库"></a>pandas库</h3><p>前面介绍的numpy库主要是处理同质型的数值类数组数据，而pandas是用来处理表格型或异质型数据。</p><p>同样的，我们会使用下面的快捷方式导入<code>import pandas as pd</code>，使用下面我们会有pd来代替pandas，为了简化代码。</p><p>其中，你暂时只需要熟悉两个最重要的常用的数据类型：Series和DataFrame。</p><h4 id="Series类型创建"><a href="#Series类型创建" class="headerlink" title="Series类型创建"></a>Series类型创建</h4><h5 id="简单创建"><a href="#简单创建" class="headerlink" title="简单创建"></a>简单创建</h5><p>series是一种一维数组型对象，它包含了一个值序列和索引（数据标签）。</p><p>其创建需要通过<strong>函数Series</strong>来完成，下面我们来创建一个简单的序列—数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([4,7,-5,3])</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure><p>如果我们不指定索引，默认生成的索引是从0到N-1。但我们可以通过在创建时指定index来指定序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj2 = pd.Series([4,7,-5,3],index=[&#x27;d&#x27;,&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;])</span><br><span class="line">print(obj2)</span><br><span class="line">print(obj2.index)</span><br></pre></td></tr></table></figure><h5 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h5><p>从另一个角度，它是一个长度固定且有序的字典类型数据。</p><p>因此，我们也可以通过一个字典作为参数来创建Series数据类型。此时，字典的值作为Series的值，而字典的键作为Series的索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdata = &#123;&#x27;Ohio&#x27;:35000,&#x27;Texas&#x27;:71000,&#x27;Oregon&#x27;:16000,&#x27;Utah&#x27;:5000&#125;</span><br><span class="line">obj2 = pd.Series(sdata)</span><br><span class="line">print(obj3)</span><br></pre></td></tr></table></figure><p>如上，产生的Series的索引是排序好的字典键。同样的，我们可以通过自定义索引来进行数据的筛选和排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdata = &#123;&#x27;Ohio&#x27;:35000,&#x27;Texas&#x27;:71000,&#x27;Oregon&#x27;:16000,&#x27;Utah&#x27;:5000&#125;</span><br><span class="line">obj2 = pd.Series(sdata，index=[&#x27;California&#x27;,&#x27;Ohio&#x27;,&#x27;Oregon&#x27;,&#x27;Texas&#x27;])</span><br><span class="line">print(obj2)</span><br></pre></td></tr></table></figure><p>如果设置的索引（’California’）没有出现在字典中，则设置值为NaN（这是pandas中标记缺失值的方式），而字典中的（’Utah’）并不在索引中，所以他被排除在结果对象外。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>我们可以通过属性values和属性index来获取Series对象的值和索引（默认索引与range函数返回结果类似）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([4,7,-5,3])</span><br><span class="line">print(obj.values)</span><br><span class="line">print(obj.index) #返回对象与range(4)类似</span><br></pre></td></tr></table></figure><p>Series数据自身和其索引都具有name属性，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sdata = &#123;&#x27;Ohio&#x27;:35000,&#x27;Texas&#x27;:71000,&#x27;Oregon&#x27;:16000,&#x27;Utah&#x27;:5000&#125;</span><br><span class="line">obj2 = pd.Series(sdata，index=[&#x27;California&#x27;,&#x27;Ohio&#x27;,&#x27;Oregon&#x27;,&#x27;Texas&#x27;])</span><br><span class="line"># 给oobj2命名</span><br><span class="line">obj2.name = &#x27;population&#x27;</span><br><span class="line">obj2.index.name = &#x27;state&#x27;</span><br></pre></td></tr></table></figure><p>而且Series具有自动对齐的特性—数据类型的对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1 = pd.Series([4,7,-5,3],dtype=int64)</span><br><span class="line">obj2 = pd.Series([4,7,-5,3],dtype=float64)</span><br><span class="line">print(obj2+obj1)</span><br></pre></td></tr></table></figure><h4 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h4><p>它同样可以对数据进行类似与NumPy的操作，数学函数、与标量相乘、布尔索引进行数据过滤、判断相关值是否存在……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj2 = pd.Series([4,7,-5,3],index=[&#x27;d&#x27;,&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;])</span><br><span class="line">print(obj2)</span><br><span class="line"># 布尔索引进行过滤</span><br><span class="line">print(obj2[obj2&gt;2])</span><br><span class="line"># 与标量相乘</span><br><span class="line">print(obj2*2)</span><br><span class="line"># 数学函数</span><br><span class="line">print(np.exp(obj2))</span><br><span class="line"># 判断是否存在</span><br><span class="line">print(&#x27;b&#x27; in obj2)</span><br><span class="line">print(&#x27;e&#x27; in obj2)</span><br></pre></td></tr></table></figure><h5 id="判断缺失值"><a href="#判断缺失值" class="headerlink" title="判断缺失值"></a>判断缺失值</h5><p>我们在此会通过isnull和notnull方法来实现缺失值的查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdata = &#123;&#x27;Ohio&#x27;:35000,&#x27;Texas&#x27;:71000,&#x27;Oregon&#x27;:16000,&#x27;Utah&#x27;:5000&#125;</span><br><span class="line">obj2 = pd.Series(sdata，index=[&#x27;California&#x27;,&#x27;Ohio&#x27;,&#x27;Oregon&#x27;,&#x27;Texas&#x27;])</span><br><span class="line">print(obj3.isnull)</span><br><span class="line">print(obj3.notnull)</span><br></pre></td></tr></table></figure><h5 id="改变已有索引"><a href="#改变已有索引" class="headerlink" title="改变已有索引"></a>改变已有索引</h5><p>Series可以通过按位赋值的方式来改变索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1 = pd.Series([4,7,-5,3])</span><br><span class="line">obj.index = [&#x27;Bob&#x27;,&#x27;Steve&#x27;,&#x27;Jeff&#x27;,&#x27;Ryan&#x27;]</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure><p>今日完结。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas库&quot;&gt;&lt;a href=&quot;#pandas库&quot; class=&quot;headerlink&quot; title=&quot;pandas库&quot;&gt;&lt;/a&gt;pandas库&lt;/h3&gt;&lt;p&gt;前面介绍的numpy库主要是处理同质型的数值类数组数据，而pandas是用来处理表格型或异质型数据。</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>numpy常用函数</title>
    <link href="https://xiaowog.top/2022/03/13/03.13-numpy%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowog.top/2022/03/13/03.13-numpy%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2022-03-13T08:33:13.000Z</published>
    <updated>2022-03-29T15:48:25.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a>numpy库</h3><h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><h5 id="dot函数详解"><a href="#dot函数详解" class="headerlink" title="dot函数详解"></a>dot函数详解</h5><p>在前面的<a href="https://xiaowog.top/2022/03/02/numpy%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/">基础三</a>中我们提了矩阵内积函数dot，但只是简单的介绍，下面通过几个例子，想要大家更好的理解该函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">y = np.array([[6,23],[-1,7],[8,9]])</span><br><span class="line"># 下面两个表达式相等</span><br><span class="line">print(x.dot(y))</span><br><span class="line">print(np.dot(x,y))</span><br></pre></td></tr></table></figure><p>一个二维数组和一个长度合适的一维数组之间的矩阵乘积，其结果是一个一维数组（二维数组的列数等于一维数组的行数）</p><p>特殊符号@也可作为矩阵点乘操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">y = np.array([[6,23],[-1,7],[8,9]])</span><br><span class="line">print(x@y)</span><br></pre></td></tr></table></figure><h5 id="linalg–矩阵分解"><a href="#linalg–矩阵分解" class="headerlink" title="linalg–矩阵分解"></a>linalg–矩阵分解</h5><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">diag</td><td align="left">将一个方阵的对角（或非对角）元素作为一维数组返回，或者将一维数组转换成一个方阵，并且在非对角线上有零点</td></tr><tr><td align="left">dot</td><td align="left">矩阵点乘</td></tr><tr><td align="left">trace</td><td align="left">计算对角元素和</td></tr><tr><td align="left">det</td><td align="left">计算矩阵的行列式</td></tr><tr><td align="left">eig</td><td align="left">计算方阵的特征值和特征向量</td></tr><tr><td align="left">inv</td><td align="left">计算方阵的逆矩阵</td></tr><tr><td align="left">pinv</td><td align="left">计算矩阵的伪逆</td></tr><tr><td align="left">qr</td><td align="left">进行矩阵的qr分解（q是正交矩阵，r是上三角矩阵）</td></tr><tr><td align="left">svd</td><td align="left">计算奇异值分解（SVD）</td></tr><tr><td align="left">solve</td><td align="left">求解x的线性系统Ax = b，其中A是方阵</td></tr><tr><td align="left">lstsq</td><td align="left">计算Ax = b的最小二乘解</td></tr></tbody></table><h4 id="伪随机数生成"><a href="#伪随机数生成" class="headerlink" title="伪随机数生成"></a>伪随机数生成</h4><p>numpy库中含random模块，可以高效地生成多种概率分布下的完整样本值数组。</p><h5 id="normal函数"><a href="#normal函数" class="headerlink" title="normal函数"></a>normal函数</h5><p>返回一个正态分布样本数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples = np.random.normal(size=(4,4))</span><br><span class="line">print(samples)</span><br></pre></td></tr></table></figure><p>我们称这些数据为伪随机数，因为他们是由于具有确定性行为地算法根据随机数生成器中的随机数种子生成的，你可以通过<code>np.random.seed()</code>函数来更改随机数产成相同的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(1234)</span><br><span class="line">samples = np.random.normal(size=(4,4))</span><br><span class="line">print(samples)</span><br></pre></td></tr></table></figure><p>np.random中的数据生成函数公用了一个全局的随机数种子。你也可以通过使用np.random.RandomState生成一个随机数生成器，是使数据独立于其他的随机数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(1234)</span><br><span class="line">print(rng.randn(10)￼)</span><br></pre></td></tr></table></figure><h5 id="random常用函数"><a href="#random常用函数" class="headerlink" title="random常用函数"></a>random常用函数</h5><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>seed</td><td>向随机数生成器传递随机状态种子</td></tr><tr><td>permutation</td><td>返回一个序列的随机排序，或者返回一个乱序的整数范围序列</td></tr><tr><td>shuffle</td><td>随机排列一个序列</td></tr><tr><td>rand</td><td>从均匀分布中抽取样本</td></tr><tr><td>randint</td><td>根据给定的由低到高的范围抽取随机整数</td></tr><tr><td>randn</td><td>从均值0方差1的正态分布中抽取样本</td></tr><tr><td>binomial</td><td>从二项分布中抽取样本</td></tr><tr><td>normal</td><td>从正态分布中抽取样本</td></tr><tr><td>beta</td><td>从beta分布中抽取样本</td></tr><tr><td>chisquare</td><td>从卡方分布中抽取样本</td></tr></tbody></table><p>到此，numpy函数基础就结束了。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;numpy库&quot;&gt;&lt;a href=&quot;#numpy库&quot; class=&quot;headerlink&quot; title=&quot;numpy库&quot;&gt;&lt;/a&gt;numpy库&lt;/h3&gt;&lt;h4 id=&quot;线性代数&quot;&gt;&lt;a href=&quot;#线性代数&quot; class=&quot;headerlink&quot; title=&quot;线</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>numpy操作</title>
    <link href="https://xiaowog.top/2022/03/13/03.13-numpy%E6%93%8D%E4%BD%9C/"/>
    <id>https://xiaowog.top/2022/03/13/03.13-numpy%E6%93%8D%E4%BD%9C/</id>
    <published>2022-03-13T01:20:15.000Z</published>
    <updated>2022-03-29T15:48:01.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a>numpy库</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>和python的内建列表相似，ndarray数据也可以使用sort方法进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(6)</span><br><span class="line">print(arr.sort)</span><br></pre></td></tr></table></figure><p>在多维函数中，你可以通过传递一个参数axis来指定沿着哪一轴向进行排序，例如<code>arr.sort(axis = 0)</code>为对每一列进行拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(3,4)</span><br><span class="line">print(arr.sort(axis=0))</span><br><span class="line"></span><br><span class="line"># 对每一行进行排序</span><br><span class="line">print(arr.sort(1))</span><br></pre></td></tr></table></figure><p>同样的，和其他方法相似，他返回的是原数组的视图，可以通过修改视图来修改原数组，而顶层的<code>np.sort</code>函数返回的是对原数组的拷贝，而不是视图。</p><p>在没有把握之前可以先用顶层函数进行排序，保留原数组，避免对原数组进行直接修改。</p><h4 id="基础集合操作"><a href="#基础集合操作" class="headerlink" title="基础集合操作"></a>基础集合操作</h4><h5 id="唯一值排序"><a href="#唯一值排序" class="headerlink" title="唯一值排序"></a>唯一值排序</h5><p>numpy库中包含了一些对一维ndarray数组进行操作的方法，其中，最常用的一个函数就是<code>np.unique</code>，返回数组中唯一值的排序后形成的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([1,2,3,5,8,1,4,2,3,8,5])</span><br><span class="line">print(np.unique(arr)) # [1,2,3,4,5,8]</span><br><span class="line">arr1 = np.array([&#x27;Joe&#x27;,&#x27;Jack&#x27;,&#x27;Jack&#x27;,&#x27;BOb&#x27;,&#x27;Will&#x27;,&#x27;BOb&#x27;,&#x27;Joe&#x27;])</span><br><span class="line">print(np.unique(arr1))</span><br></pre></td></tr></table></figure><h5 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h5><p>另一个常用的函数，<code>np.in1d</code>可以检查一个数组中的值是否在另一个数组中，并返回一个布尔值数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valus = arr.array([6,0,0,3,4,7])</span><br><span class="line">print(np.unique(valus,[2,3,6]))</span><br></pre></td></tr></table></figure><h5 id="集合操作总结"><a href="#集合操作总结" class="headerlink" title="集合操作总结"></a>集合操作总结</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>unique(x)</td><td>计算x数组的唯一值，并排序</td></tr><tr><td>intersect1d(x,y)</td><td>计算x和y的交集，并排序</td></tr><tr><td>union1d(x,y)</td><td>计算x和y的并集，并排序</td></tr><tr><td>setdiff1d(x,y)</td><td>差集，计算不在y中的x元素</td></tr><tr><td>in1d(x,y)</td><td>计算x中的元素是否包含在y中，返回一个布尔值数组</td></tr><tr><td>setxor1d(x,y)</td><td>异或集，在x中或在y中，但不是属于x，y交集的元素</td></tr></tbody></table><h4 id="文件的输入和输出"><a href="#文件的输入和输出" class="headerlink" title="文件的输入和输出"></a>文件的输入和输出</h4><p>Numpy可以将数据以文本或二进制文件的形式储存到硬盘中，也可以将储存在硬盘中的文件读取出来。利用到的函数为<code>np.save()</code>和<code>np.load()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(10)</span><br><span class="line">np.save(&#x27;some_array&#x27;,arr)</span><br></pre></td></tr></table></figure><p>这样，我们就把arr数组存到文件some_array.npy中了，可以看出，如果文件存放路径中没有写文件类型，他会默认加上**.npy**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.load(&#x27;some_array.npy&#x27;)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure><p>此时，文件名中必须加后缀文件类型。</p><p>你也可以使用<code>np.savez</code>将多个数组以字典(未压缩)的形式保存在同一个**.npz**文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.arange(5)</span><br><span class="line">arr2 = np.arange(5,10)</span><br><span class="line">np.savez(&#x27;array_achive.npz&#x27;,a=arr1,b=arr2)</span><br></pre></td></tr></table></figure><p>当你载入一个**.npz**文件的时候，你会获得一个字典型的对象，进而获得一个单个数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch = np.load(&#x27;array_achive.npz&#x27;)</span><br><span class="line">print(arch[b])</span><br></pre></td></tr></table></figure><p>而np.savez_compressed将多个数组以压缩的形式保存在同一个**.npz**文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.arange(5)</span><br><span class="line">arr2 = np.arange(5,10)</span><br><span class="line">np.savez_compressed(&#x27;arrays_compressed.npz&#x27;,a=arr1,b=arr2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;numpy库&quot;&gt;&lt;a href=&quot;#numpy库&quot; class=&quot;headerlink&quot; title=&quot;numpy库&quot;&gt;&lt;/a&gt;numpy库&lt;/h3&gt;&lt;h4 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>numpy计算</title>
    <link href="https://xiaowog.top/2022/03/10/03.10-numpy%E8%AE%A1%E7%AE%97/"/>
    <id>https://xiaowog.top/2022/03/10/03.10-numpy%E8%AE%A1%E7%AE%97/</id>
    <published>2022-03-10T05:29:43.000Z</published>
    <updated>2022-03-29T15:47:13.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a>numpy库</h3><h4 id="where函数"><a href="#where函数" class="headerlink" title="where函数"></a>where函数</h4><p>对数组中的每个元素做三元表达式<code>x if condition else y</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xarr = np.array([1.1,1.2,1.3,1.4,1.5])</span><br><span class="line">xarr = np.array([2.1,2.2,2.3,2.4,2.5])</span><br><span class="line">cond = np.array([True,False,True,True,False])</span><br><span class="line">result = where(cond, xarr, yarr)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>注：np.where的第二个参数和第三个参数可以不是数组，可以是标量（例如数字）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个4*4的随机数组，大于零的替换为正一，小于零的替换成负一</span><br><span class="line">arr = np.random.randn(4,4)</span><br><span class="line">print(arr)</span><br><span class="line">print(np.where(arr&gt;0,1,-1))</span><br></pre></td></tr></table></figure><p>也可以将标量与数组结合，如果是两个数组，必须同等大小。</p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>如果对整个数组进行统计值或关于轴向数据的处理，可以采用聚合函数（也叫缩减函数），比如sum,mean,std（标准差）</p><p>既可以通过直接调用实例的方法，也可以使用顶层的numpy函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(5,4)</span><br><span class="line">print(arr)</span><br><span class="line"># 对整个数组求平均</span><br><span class="line">print(arr.mean())</span><br><span class="line">print(np.mean(arr))</span><br><span class="line"># 对整个数组求和</span><br><span class="line">print(arr.sum())</span><br></pre></td></tr></table></figure><p>同样，这些函数可以接收一个可选参数axis，例如一个二维数组，axis=1表示对数组的每一行进行操作，axis=0则表示对数组的每一列进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(5,4)</span><br><span class="line">print(arr.mean(axis = 1))</span><br><span class="line">print(arr.sum(axis=0))</span><br></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>例如cumsum（累加）和cumprod（累乘）方法不会聚合，他们会返回一个中间结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 对整个数组进行累加</span><br><span class="line">arr = np.array([0,1,2,3,4,5,6,7])</span><br><span class="line">print(arr.cumsum())</span><br><span class="line"># 对数组中的每一列进行累加</span><br><span class="line">arr1 = np.array([[0,1,2],[3,4,5],[6,7,8]])</span><br><span class="line">print(arr.cumsum(axis = 0))</span><br><span class="line"># 对数组中的每一行进行累乘</span><br><span class="line">print(arr1.cumprod(axis=  1))</span><br></pre></td></tr></table></figure><h5 id="基础数组统计方法"><a href="#基础数组统计方法" class="headerlink" title="基础数组统计方法"></a>基础数组统计方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sum</td><td>沿着轴向计算所有元素的累和，0长度的数组，累和为0</td></tr><tr><td>mean</td><td>数学平均，0长度的数组平均值为NaN</td></tr><tr><td>std，var</td><td>标准差和方差，可以选择自由度调整（默认分母为n）</td></tr><tr><td>min，max</td><td>最小值和最大值</td></tr><tr><td>argmin，argmax</td><td>最小值和最大值的位置</td></tr><tr><td>cumsum</td><td>从0开始元素累加和</td></tr><tr><td>cumprod</td><td>从1开始元素累乘积</td></tr></tbody></table><h4 id="布尔值数组"><a href="#布尔值数组" class="headerlink" title="布尔值数组"></a>布尔值数组</h4><p>通过条件判断生成的布尔值数组，True为1，False为0，所以可以通过sum来计算数组中True的个数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(100)</span><br><span class="line">print((arr &gt; 0).sum())</span><br></pre></td></tr></table></figure><p>对于布尔值数组，有两个很有用的方法，any和all：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bools = np.array([False,False,True,False])</span><br><span class="line">bools.any()</span><br><span class="line">bools.all()</span><br></pre></td></tr></table></figure><p>注：非布尔值数组同样也适用，所有的非0元素都会按True处理。</p><p>今日完结。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;numpy库&quot;&gt;&lt;a href=&quot;#numpy库&quot; class=&quot;headerlink&quot; title=&quot;numpy库&quot;&gt;&lt;/a&gt;numpy库&lt;/h3&gt;&lt;h4 id=&quot;where函数&quot;&gt;&lt;a href=&quot;#where函数&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>numpy通用函数</title>
    <link href="https://xiaowog.top/2022/03/02/03.02-numpy%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowog.top/2022/03/02/03.02-numpy%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2022-03-02T00:55:06.000Z</published>
    <updated>2022-03-29T15:46:47.051Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ndarray数据"><a href="#ndarray数据" class="headerlink" title="ndarray数据"></a>ndarray数据</h3><h4 id="进阶索引和切片"><a href="#进阶索引和切片" class="headerlink" title="进阶索引和切片"></a>进阶索引和切片</h4><h5 id="神奇索引"><a href="#神奇索引" class="headerlink" title="神奇索引"></a>神奇索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.empty((8,4))</span><br><span class="line">for i in range(8):</span><br><span class="line">arr[i] = i</span><br><span class="line">print(arr)</span><br><span class="line">print(arr[[4,3,0,6]) # 最高维度，此处是二维--行</span><br><span class="line">print(arr[[4,3,0,6],[2,3，1，4]])</span><br><span class="line">print(arr[[-3,-5,-7]]) # 负的索引，将从尾部进行选择</span><br></pre></td></tr></table></figure><p>​    如上面的倒数第二个索引，两个列表元素依次为行、列，对应位置组成一个索引，如下面的第一个元素位置为（4，2），所以前后的长度必须相同或者其中一个为一。</p><p>​    注：神奇索引与切片和布尔索引不同，它总是将数据复制到一个新的数组中，所以改变神奇索引 中的值并不会修改原数组</p><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><h5 id="数组转置和换轴"><a href="#数组转置和换轴" class="headerlink" title="数组转置和换轴"></a>数组转置和换轴</h5><p>​    转置是一种特殊的数据重组形式，它可以返回底层数据的视图而不需要复制任何内容，所以修改转置数组的值会改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(15).reshape((3,5))</span><br><span class="line">print(arr)</span><br><span class="line">arr1 = arr.T</span><br><span class="line">print(arr1)</span><br><span class="line">arr1[(0,2)] = 0</span><br><span class="line">print(arr)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure><p>​    对于更高维度的数组，transpose方法可以接受包含轴编号的元组，用于置换轴，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(16).reshape((2,2,4))</span><br><span class="line">arr1 = arr.transpose((1,0,2)) # 交换第三维和第二维---行</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure><p>也可以通过swapaxes的方法交换两个轴，如 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arnage(16).reshape((2,2,4))</span><br><span class="line">arr1 = arr.swapaxes(1,2)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure><p>swapaxes同样返回的是数据的视图，而没对数据进行复制。</p><h5 id="矩阵的内积"><a href="#矩阵的内积" class="headerlink" title="矩阵的内积"></a>矩阵的内积</h5><p>​    一个行向量乘以一个列向量的内积，又叫作点积，结果为一个数，如同矩阵的乘法，我们使用np.dot可实现上述操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(6,3)</span><br><span class="line">print(arr)</span><br><span class="line">np.dot(drr,drr.T) #得到6行3列的矩阵</span><br></pre></td></tr></table></figure><h4 id="通用函数–快速的族元素数组函数"><a href="#通用函数–快速的族元素数组函数" class="headerlink" title="通用函数–快速的族元素数组函数"></a>通用函数–快速的族元素数组函数</h4><p>​    通用函数–是指在ndarray数据中进行元素操作的函数，是对某些简单函数的封装，如sqrt或exp函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = arange(10)</span><br><span class="line">print(arr)</span><br><span class="line"># 对每个元素进行开平方</span><br><span class="line">print(np.sqrt(arr))</span><br><span class="line"># 将每个元素作为e的指数得到结果</span><br><span class="line">print(np.exp(arr))</span><br></pre></td></tr></table></figure><p>还有一些二元通用函数，如add或maximum函数，返回一个数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(8)</span><br><span class="line">y = np.random.randn(8)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"># 两个数组对应位置取两组最大</span><br><span class="line">print(np.maximum(x,y))</span><br><span class="line"># 返回两个数组对应位置的数字相加</span><br><span class="line">print(np.add(x,y))</span><br></pre></td></tr></table></figure><p>​    同样也是有返回多个数组，如modf，返回数组的整数部分和小数部分，两部分的的数组符号与原数组相同，整数部分一浮点型表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(7)*5</span><br><span class="line">print(arr)</span><br><span class="line">remainder, whole_part = np.modf(arr)</span><br><span class="line">print(remainder)</span><br><span class="line">print(whole_part)</span><br></pre></td></tr></table></figure><p>注：整数型ndarray也可以对其进行modf，得到小数部分全部为0.</p><p>通用函数也可以接受一个可选参数out，将得到的结果赋值给out</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(7)*5</span><br><span class="line">print(arr)</span><br><span class="line">np.sqrt(arr,arr)</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure><h5 id="一元通用函数"><a href="#一元通用函数" class="headerlink" title="一元通用函数"></a>一元通用函数</h5><table><thead><tr><th>函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td>abs，fabs</td><td align="center">对每个元素（整数，浮点数或复数）进行取绝对值</td></tr><tr><td>sqrt</td><td align="center">计算每个元素的平方根（与arr ** 0.5相等）</td></tr><tr><td>square</td><td align="center">计算每个元素的平方（与arr ** 2相等）</td></tr></tbody></table><h5 id="二元通用函数"><a href="#二元通用函数" class="headerlink" title="二元通用函数"></a>二元通用函数</h5><table><thead><tr><th>函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td>add</td><td align="center">将数组对应元素相加</td></tr><tr><td>subtract</td><td align="center">在第二个元素中，去除第一个数组所含的元素</td></tr><tr><td>multiply</td><td align="center">将数组对应元素相乘</td></tr><tr><td>divide，floor_divide</td><td align="center">除或整除</td></tr><tr><td>power</td><td align="center">将第二个数组的元素作为第一个数组对应元素的幂次方</td></tr><tr><td>maximum，fmax</td><td align="center">逐个元素的计算最大值，fmax忽略NaN</td></tr><tr><td>minimum，fmin</td><td align="center">逐个元素的计算最小值，fmin忽略NaN</td></tr><tr><td>mod</td><td align="center">按元素的求模计算（即求除法的余数）</td></tr><tr><td>copysign</td><td align="center">将第一个数组的符号值改为第二个数组的符号值</td></tr><tr><td>greater，less，equal，greater_equal……</td><td align="center">进行逐个元素比较，返回布尔值数组（与数字&gt;，&lt;，==，&gt;=……）</td></tr><tr><td>logical_and，logical_or，logical_xor</td><td align="center">进行逐个元素的逻辑操作（与逻辑操作符&amp;，|，^效果一致）</td></tr></tbody></table><h5 id="meshgrid函数"><a href="#meshgrid函数" class="headerlink" title="meshgrid函数"></a>meshgrid函数</h5><p>meshgrid函数是用两个坐标轴上的点在平面上画网格。<br>用法：<br>　　[X,Y]=meshgrid(x,y)<br>　　[X,Y]=meshgrid(x)与[X,Y]=meshgrid(x,x)是等同的<br>　　[X,Y,Z]=meshgrid(x,y,z)生成三维数组，可用来计算三变量的函数和绘制三维立体图</p><p>​    就拿[X,Y]=meshgrid(x,y)第一个用法举例，该函数将向量x和y定义的区域转换成矩阵X和Y,其中矩阵X的行向量是向量x的<strong>简单复制</strong>，而矩阵Y的列向量是向量y的<strong>简单复制</strong>，假设<strong>x</strong>是长度为<strong>m</strong>的向量，<strong>y</strong>是长度为<strong>n</strong>的向量，则最终生成的矩阵X和Y的维度都是 <strong>n*m</strong> 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ndarray数据&quot;&gt;&lt;a href=&quot;#ndarray数据&quot; class=&quot;headerlink&quot; title=&quot;ndarray数据&quot;&gt;&lt;/a&gt;ndarray数据&lt;/h3&gt;&lt;h4 id=&quot;进阶索引和切片&quot;&gt;&lt;a href=&quot;#进阶索引和切片&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PycharmError:failed to send plot to http://127.0.0.1:63342</title>
    <link href="https://xiaowog.top/2022/03/01/03.01-PycharmError/"/>
    <id>https://xiaowog.top/2022/03/01/03.01-PycharmError/</id>
    <published>2022-03-01T02:28:03.000Z</published>
    <updated>2022-03-10T06:04:25.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h3><p>pycharm 错误：无法将绘图发送到 <code>http://127.0.0.1:63342</code></p><p>使用pycharm连接远程Python解释器时，在plt.show()时绘制错误。</p><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>​    <code>http://127.0.0.1:63342</code>中的63342是呈现图像的环境变量，远程解释器尝试把远程将图像数据发送到远程服务器 <code>http://127.0.0.1:63342</code>，但被拒绝。</p><p>​    SciView运行机制是：本地notebook的Pyvharm会监听127.0.0.1：63342，所以Pycharm会接收图像数据后会在SciView中显示。</p><h4 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h4><p>可能是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(14, 14), dpi=300)  # 创建画布</span><br></pre></td></tr></table></figure><p>这里的figsize的数值太大，或者dpi分辨率太高。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    进入pycharm（可能只有专业版有）中的 setting – &gt; tools——&gt; Python scientific, 然后取消选择 ☑ Show plot in tool windosw。</p><p>或者降低figsize和dpi的大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题出现&quot;&gt;&lt;a href=&quot;#问题出现&quot; class=&quot;headerlink&quot; title=&quot;问题出现&quot;&gt;&lt;/a&gt;问题出现&lt;/h3&gt;&lt;p&gt;pycharm 错误：无法将绘图发送到 &lt;code&gt;http://127.0.0.1:63342&lt;/code&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="坑" scheme="https://xiaowog.top/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>numpy切片与索引</title>
    <link href="https://xiaowog.top/2022/02/28/02.28-numpy%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
    <id>https://xiaowog.top/2022/02/28/02.28-numpy%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95/</id>
    <published>2022-02-28T00:32:25.000Z</published>
    <updated>2022-03-29T15:46:22.188Z</updated>
    
    <content type="html"><![CDATA[<p>补录：astype方法总是会重新生成一个新数组。</p><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><h4 id="NumPy数组算术"><a href="#NumPy数组算术" class="headerlink" title="NumPy数组算术"></a>NumPy数组算术</h4><p>ndarray数组支持进行批量操作而无需任何循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[1,2,3],[4,5,6]])</span><br><span class="line"># 对应位置上的元素分别相乘</span><br><span class="line">print(arr * arr)</span><br><span class="line"># 对应位置上的元素分别相减</span><br><span class="line">print(arr - arr)</span><br><span class="line"># 对应位置上的元素分别除一，一为被除数</span><br><span class="line">print(1 / arr)</span><br><span class="line"># 对应位置上的元素分别开根号</span><br><span class="line">print(arr ** 0.5)</span><br></pre></td></tr></table></figure><p>同尺寸数组之间的比较，会返回一个布尔值的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">arr2 = np.array([[0,4,1],[7,2,12])</span><br><span class="line">print(arr1&gt;arr2)</span><br></pre></td></tr></table></figure><p>注：大部分的操作是建立在相同尺寸的条件上的。</p><h4 id="基础索引与切片"><a href="#基础索引与切片" class="headerlink" title="基础索引与切片"></a>基础索引与切片</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>一维数组的读取操作和列表操作类似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(10)</span><br><span class="line"># 切片读取整个数组</span><br><span class="line">print(arr) #省略[:]</span><br><span class="line">print(arr[:])</span><br><span class="line"># 索引读取一维数组的第六位元素</span><br><span class="line">print(arr[5])</span><br><span class="line"># 切片读取一维数组的五六七位元素</span><br><span class="line">print(arr[5:8])</span><br><span class="line">print(arr[5,6,7])</span><br><span class="line"># 切片读取一维数组的前四位元素</span><br><span class="line">print(arr[:4])</span><br><span class="line"># 修改五六七位元素为12</span><br><span class="line">arr[5:8]=12</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure><p>​    数组的切片为原数组的视图，并不会进行复制，修改ndarray的切片会反映到原数组上。</p><p>​    而对于python内建列表的话，通过索引复制给另一个变量的时候，两个变量公用一块内存块，而使用切片后就是两块地址。</p><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>​    在一个二维数组，每个索引值对应的元素不再是一个值，而是一个一维数组。(根据最高维进行索引)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.array([[1,2,3],[4,5,6],[7,8,9]])</span><br><span class="line">print(arr2[1])</span><br><span class="line">print(arr2)</span><br></pre></td></tr></table></figure><p>当然也可以通过别的方法来获取单个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.array([[1,2,3],[4,5,6],[7,8,9]])</span><br><span class="line">print(arr[0][2])</span><br><span class="line">print(arr2[0,2])</span><br></pre></td></tr></table></figure><p>二维数组的切片操作：（对高维操作，对低维操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.array([[1,2,3],[4,5,6],[7,8,9]])</span><br><span class="line"># 切片读取数组的前两列</span><br><span class="line">print([:,:2])</span><br><span class="line"># 切片读取数组的前两行</span><br><span class="line">print([:2])</span><br></pre></td></tr></table></figure><p>三维数组也是如此：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr3 = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]</span><br><span class="line">print(arr3)</span><br><span class="line">print(arr3[:,:,:])</span><br><span class="line">print(arr3[0])</span><br><span class="line">print(arr[1,0]) #读取[7，8，9]</span><br><span class="line">print(arr[:1,:1,:2])</span><br></pre></td></tr></table></figure><p>也可以进行copy，修改等的操作。</p><h4 id="copy函数复制"><a href="#copy函数复制" class="headerlink" title="copy函数复制"></a>copy函数复制</h4><p>如果你想要得到切片的复制而不是一份视图的话，你必须显式地复制这个数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(10)</span><br><span class="line">print(arr)</span><br><span class="line">arr1 = arr[5:8].copy()</span><br><span class="line">arr1[1] = 0</span><br><span class="line">print(arr1)</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>在索引数组时可以传入布尔值数组，来进行数据的筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">bool_data = data &gt;5</span><br><span class="line">print(data[bool_data])</span><br><span class="line">print(data[~bool_data])</span><br><span class="line">bool_data2 = data&lt;2 | data&gt;7</span><br><span class="line">print(data[bool_data2])</span><br><span class="line"># 可以对所筛选的值进行修改</span><br><span class="line">data[~bool_data2] = 0</span><br></pre></td></tr></table></figure><ul><li>通过对数组进行逻辑运算来获得布尔数组，然后将其传入索引中，进而获得符合条件的元素。</li><li>同样，也可以用户自己定义布尔数组，但布尔数组的形状必须和所进行筛选的数组形状相同，否则会报错。</li><li>使用布尔数组索引数据时，总是生成数据的拷贝，即使返回数组与原数组相同。</li><li><code>~</code>这符号可以在你想要对一个通用条件取反时使用</li><li>可以使用数学操作符<code>&amp;</code>和<code>|</code>进行与和或的逻辑运算</li></ul><p>今日完毕。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;补录：astype方法总是会重新生成一个新数组。&lt;/p&gt;
&lt;h3 id=&quot;numpy&quot;&gt;&lt;a href=&quot;#numpy&quot; class=&quot;headerlink&quot; title=&quot;numpy&quot;&gt;&lt;/a&gt;numpy&lt;/h3&gt;&lt;h4 id=&quot;NumPy数组算术&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数组的创建和属性</title>
    <link href="https://xiaowog.top/2022/02/27/02.27-numpy%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>https://xiaowog.top/2022/02/27/02.27-numpy%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B1%9E%E6%80%A7/</id>
    <published>2022-02-27T07:20:16.000Z</published>
    <updated>2022-05-20T16:19:02.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>numpy数据类型（ndarray）的优点：</p><ul><li>Numpy 的数据储存在连续的内存块上。</li><li>算法库是有c语言编写的，运行时间少，无需检查类型和其他操作。</li><li>全局数组进行复杂计算无需循环</li><li>内存量小。</li></ul><p><strong>注：一下numpy全用缩写np来表示。</strong></p><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><h5 id="array创建"><a href="#array创建" class="headerlink" title="array创建"></a>array创建</h5><p>​    array函数可以把任意的序列型对象转换成数组，默认通过复制来创建数组数据。语法格式：</p><p><code>np.array(object, dtype=None, copy=True, order=None,ndmin=0)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>object</td><td>表示一个数组序列</td></tr><tr><td>dtype</td><td>可选参数，可以指定数组的数据类型</td></tr><tr><td>copy</td><td>可选参数，表示数组是否进行复制</td></tr><tr><td>order</td><td>创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td>ndmin</td><td>用于指定数组的最小维度。</td></tr></tbody></table><p>创建一维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data0 = np.array([1,2,3,1])</span><br><span class="line">print(data0)</span><br></pre></td></tr></table></figure><p>创建二维数组：</p><p>嵌套序列的元素的长度相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1 = np.array([[1,2,3,4],[5,6,7,8]])</span><br><span class="line">print(data1)</span><br></pre></td></tr></table></figure><p>创建三维数组：</p><p>使用ndmin参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data3 = np.array([1, 2, 3, 4, 5, 6], ndmin=3)</span><br><span class="line">print(data3)</span><br><span class="line"># 输出为[[[1 2 3 4 5 6]]]</span><br></pre></td></tr></table></figure><p>改变数组类型：</p><p>使用参数dtype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data4 = numpy.array([2,4,6,8],dtype=&quot;complex&quot;)</span><br><span class="line">print(data4)</span><br><span class="line"># 输出为[2.+0.j 4.+0.j 6.+0.j 8.+0.j]</span><br></pre></td></tr></table></figure><h5 id="asarray创建"><a href="#asarray创建" class="headerlink" title="asarray创建"></a>asarray创建</h5><p>​    类似于array，同样是将输入数据转换成ndarray数组。但如何输入已经是ndarray数据则不再进行复制，且默认order参数为C（行方向）。语法格式如下：</p><p><code>np.asarray(a, dtype = None, order = None)</code></p><h5 id="arange函数创建"><a href="#arange函数创建" class="headerlink" title="arange函数创建"></a>arange函数创建</h5><p>arange类似于range，但arange返回值类型为ndarray数组，用来创建给定数值范围的数组。语法格式如下：</p><p><code>numpy.arange(start, stop, step, dtype)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>起始值，默认为0</td></tr><tr><td>stop</td><td>终止值，注意不包含</td></tr><tr><td>step</td><td>步长，默认为1</td></tr><tr><td>dtype</td><td>可选参数，修改数组的数据类型</td></tr></tbody></table><p>创建一维数组[0，1，2，3，4，5]：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = np.arange(6)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h5 id="linspace创建等差数组"><a href="#linspace创建等差数组" class="headerlink" title="linspace创建等差数组"></a>linspace创建等差数组</h5><p>在指定的数值区间内，返回均匀间隔的一维等差数组，默认均分 50 份，语法格式如下：</p><p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>序列的起始值</td></tr><tr><td>stop</td><td>序列的终止值</td></tr><tr><td>num</td><td>要生成的等步长的样本数量，默认为50</td></tr><tr><td>endpoint</td><td>该值为true时，数列中包stop值，反之不包含，默认是True。</td></tr><tr><td>retstep</td><td>如果为 True 时，生成的数组中会显示间距，反之不显示。</td></tr><tr><td>dtype</td><td>数组的数据类型</td></tr></tbody></table><h5 id="特殊创建"><a href="#特殊创建" class="headerlink" title="特殊创建"></a>特殊创建</h5><p>ones，zeros，empy函数分别创建全为1，全为0，和没有初始值的数组。</p><p><strong>如果想要创建高维数组，需要给shape传递一个元组（创建一维数组时也可以用元组）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建含十个元素的一维数组</span><br><span class="line">data1 = np.ones((10))</span><br><span class="line">print(data1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建3行6列的二维数组</span><br><span class="line">data0 = np.zeros((3, 6))</span><br><span class="line">print(data0)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建3行5列的二维数组</span><br><span class="line">data_kong = np.empty((3, 5))</span><br><span class="line">print(data_kong)</span><br></pre></td></tr></table></figure><p>注意：empty函数创建未初始化的数组，有可能返回垃圾值。</p><h4 id="ndarray的属性"><a href="#ndarray的属性" class="headerlink" title="ndarray的属性"></a>ndarray的属性</h4><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>属性dtype，是一个特殊的对象—元数据(数据类型)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([1,2,3,4],dtype=np.float64)</span><br><span class="line">arr2 = np.array([1,2,3,4],dtype=np.int32)</span><br><span class="line">print(arr1.dtype)</span><br><span class="line">print(arr2.dtype)</span><br></pre></td></tr></table></figure><p>dtype给强语言带来了”类型定义“</p><p>可以通过<code>astype</code>进行数据类型的转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([1,2,3,4],dtype=np.int32)</span><br><span class="line">print(arr.dtype)</span><br><span class="line"></span><br><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">print(float.dtype)</span><br></pre></td></tr></table></figure><p>注意：从浮点数转换成整数，会直接舍弃小数点的。</p><p>也可以把只是数字组成的字符串组成的元素转换成数字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numeric_strings = np.array([&#x27;1.25&#x27;,&#x27;-9.6&#x27;,&#x27;42&#x27;],dtype=np.string_)</span><br><span class="line">numeric_strings.astype(np.float64)</span><br></pre></td></tr></table></figure><p>​    尽量避免数据类型为numpy.string_，因为numpy会修正他的大小或和删除输入且不发出警告。后面的pandas会更好的处理这种情况。</p><p>暂时到这。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;numpy&quot;&gt;&lt;a href=&quot;#numpy&quot; class=&quot;headerlink&quot; title=&quot;numpy&quot;&gt;&lt;/a&gt;numpy&lt;/h3&gt;&lt;p&gt;numpy数据类型（ndarray）的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Numpy 的数据储存在连续的内存块上。&lt;/</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>numpy数组的创建和属性</title>
    <link href="https://xiaowog.top/2022/02/27/02.27-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>https://xiaowog.top/2022/02/27/02.27-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B1%9E%E6%80%A7/</id>
    <published>2022-02-27T07:20:16.000Z</published>
    <updated>2022-03-29T15:45:27.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>numpy数据类型（ndarray）的优点：</p><ul><li>Numpy 的数据储存在连续的内存块上。</li><li>算法库是有c语言编写的，运行时间少，无需检查类型和其他操作。</li><li>全局数组进行复杂计算无需循环</li><li>内存量小。</li></ul><p><strong>注：一下numpy全用缩写np来表示。</strong></p><h4 id="ndarray的创建"><a href="#ndarray的创建" class="headerlink" title="ndarray的创建"></a>ndarray的创建</h4><h5 id="array函数的创建"><a href="#array函数的创建" class="headerlink" title="array函数的创建"></a>array函数的创建</h5><p>​    array函数可以把任意的序列型对象转换成ndarray数组。通过复制来创建ndarray数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建一维数组</span><br><span class="line">data0 = np.array([1,2,3,1])</span><br><span class="line">print(data0)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建二维数组，嵌套序列（序列元素的长度相同）</span><br><span class="line">data1 = np.array([[1,2,3,4],[5,6,7,8]])</span><br><span class="line">print(data1)</span><br></pre></td></tr></table></figure><h5 id="asarray函数创建"><a href="#asarray函数创建" class="headerlink" title="asarray函数创建"></a>asarray函数创建</h5><p>​    类似于array，同样是将输入数据转换成ndarray数组。但如何输入已经是ndarray数据则不再进行复制。</p><h5 id="arange函数创建"><a href="#arange函数创建" class="headerlink" title="arange函数创建"></a>arange函数创建</h5><p>arange类似于range，但arange返回值类型为ndarray数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建一维数组[0，1，2，3，4，5]</span><br><span class="line">data = np.arange(6)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.arange(start,end,step)</span><br><span class="line"># 起始于start，不包含end。start默认为0，step默认为1.</span><br></pre></td></tr></table></figure><h5 id="特殊创建"><a href="#特殊创建" class="headerlink" title="特殊创建"></a>特殊创建</h5><p>ones，zeros，empy函数分别创建全为1，全为0，和没有初始值的数组。</p><p><strong>如果想要创建高维数组，需要给shape传递一个元组（创建一维数组时也可以用元组）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建含十个元素的一维数组</span><br><span class="line">data1 = np.ones((10))</span><br><span class="line">print(data1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建3行6列的二维数组</span><br><span class="line">data0 = np.zeros((3, 6))</span><br><span class="line">print(data0)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建3行5列的二维数组</span><br><span class="line">data_kong = np.empty((3, 5))</span><br><span class="line">print(data_kong)</span><br></pre></td></tr></table></figure><p>注意：empty函数创建未初始化的数组，有可能返回垃圾值。</p><h4 id="ndarray的属性"><a href="#ndarray的属性" class="headerlink" title="ndarray的属性"></a>ndarray的属性</h4><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>属性dtype，是一个特殊的对象—元数据(数据类型)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([1,2,3,4],dtype=np.float64)</span><br><span class="line">arr2 = np.array([1,2,3,4],dtype=np.int32)</span><br><span class="line">print(arr1.dtype)</span><br><span class="line">print(arr2.dtype)</span><br></pre></td></tr></table></figure><p>dtype给强语言带来了”类型定义“</p><p>可以通过<code>astype</code>进行数据类型的转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([1,2,3,4],dtype=np.int32)</span><br><span class="line">print(arr.dtype)</span><br><span class="line"></span><br><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">print(float.dtype)</span><br></pre></td></tr></table></figure><p>注意：从浮点数转换成整数，会直接舍弃小数点的。</p><p>也可以把只是数字组成的字符串组成的元素转换成数字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numeric_strings = np.array([&#x27;1.25&#x27;,&#x27;-9.6&#x27;,&#x27;42&#x27;],dtype=np.string_)</span><br><span class="line">numeric_strings.astype(np.float64)</span><br></pre></td></tr></table></figure><p>​    尽量避免数据类型为numpy.string_，因为numpy会修正他的大小或和删除输入且不发出警告。后面的pandas会更好的处理这种情况。</p><p>暂时到这。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;numpy&quot;&gt;&lt;a href=&quot;#numpy&quot; class=&quot;headerlink&quot; title=&quot;numpy&quot;&gt;&lt;/a&gt;numpy&lt;/h3&gt;&lt;p&gt;numpy数据类型（ndarray）的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Numpy 的数据储存在连续的内存块上。&lt;/</summary>
      
    
    
    
    
    <category term="数据分析" scheme="https://xiaowog.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>anaconda问题</title>
    <link href="https://xiaowog.top/2022/02/25/anaconda%E9%97%AE%E9%A2%98/"/>
    <id>https://xiaowog.top/2022/02/25/anaconda%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-25T04:17:11.000Z</published>
    <updated>2022-03-10T06:01:47.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="annconda的Jupyter如何修改默认文件夹的位置"><a href="#annconda的Jupyter如何修改默认文件夹的位置" class="headerlink" title="annconda的Jupyter如何修改默认文件夹的位置"></a>annconda的Jupyter如何修改默认文件夹的位置</h3><p>如图所示，打开<code>D:\anaconda\pkgs\_ipyw_jlab_nb_ext_conf-0.1.0-py39haa95532_0\etc\jupyter</code>的jupyter_notebook_config.json文件</p><p><img lazyload src="/images/loading.svg" data-src="01.png" alt="01"></p><p>输入如下代码，<code>E;\\download</code>为默认文件夹路径</p><p><img lazyload src="/images/loading.svg" data-src="02.png" alt="02"></p><p>然后在下面的文件夹（AppData为隐藏目录）里右击Jupyter快捷方式</p><p>或者直接在开始菜单里搜索Jupyter，右击打开文件位置，打开属性</p><p><img lazyload src="/images/loading.svg" data-src="03.png" alt="03"></p><p>删除目标里两个%括起来的东西（包括%）和起始位置里的内容</p><p><img lazyload src="/images/loading.svg" data-src="04.png" alt="04"></p><h3 id="anaconda的Jupyter无法自动弹出浏览器"><a href="#anaconda的Jupyter无法自动弹出浏览器" class="headerlink" title="anaconda的Jupyter无法自动弹出浏览器"></a>anaconda的Jupyter无法自动弹出浏览器</h3><p>通过win+R打开cmd，输入<code>jupyter notebook --generate-config</code>，如果在安装时未将Anconda加入到系统环境变量中，执行该命令会报错。然后输入y，得到了配置文件及其所在的文件夹。</p><p><img lazyload src="/images/loading.svg" data-src="05.png" alt="05"></p><p>复制文件位置打开，</p><p><img lazyload src="/images/loading.svg" data-src="06.png" alt="06"></p><p>找到<code>c.NotebookApp.browser = &#39;&#39;</code>这行，</p><p><img lazyload src="/images/loading.svg" data-src="07.png" alt="07"></p><p>修改为下面的代码：下面以chorme浏览器为例(其他浏览器同，但不要出现中文文件名)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import webbrowser</span><br><span class="line">webbrowser.register(&quot;chrome&quot;,None,webbrowser.GenericBrowser(r&quot;&quot;C:\Program Files\Google\Chrome\Application\chrome.exe&quot;&quot;))</span><br><span class="line">c.NotebookApp.browser = &#x27;chrome&#x27;</span><br></pre></td></tr></table></figure><p>其中<code>&quot;C:\Program Files\Google\Chrome\Application\chrome.exe&quot;</code>为你浏览器文件的地址，可以通过下面方式找到文件位置：</p><p><img lazyload src="/images/loading.svg" data-src="08.png" alt="08"></p><p><img lazyload src="/images/loading.svg" data-src="09.png" alt="09"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;annconda的Jupyter如何修改默认文件夹的位置&quot;&gt;&lt;a href=&quot;#annconda的Jupyter如何修改默认文件夹的位置&quot; class=&quot;headerlink&quot; title=&quot;annconda的Jupyter如何修改默认文件夹的位置&quot;&gt;&lt;/a&gt;an</summary>
      
    
    
    
    
    <category term="坑" scheme="https://xiaowog.top/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="https://xiaowog.top/2022/02/24/02.24-%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowog.top/2022/02/24/02.24-%E5%87%BD%E6%95%B0/</id>
    <published>2022-02-23T23:50:17.000Z</published>
    <updated>2022-04-16T05:24:58.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><p>函数可重复使用，用来实现相关联功能的代码段。函数能提高程序的模块性、代码的重复利用率。Python函数分两类，即内建函数，自定义函数。例如，print就是一个输出计算结果的函数，除了系统内置的函数之外，程序员还可以根据需要编写自己的函数。</p><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>函数定义非常简单，使用def关键字即可创建一个函数。函数在使用前必须定义，其语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 函数名 ([参数 1,参数 2…]):</span><br><span class="line">    代码</span><br><span class="line">    [return 表达式]</span><br></pre></td></tr></table></figure><ul><li>函数名的命名规范和变量的定义规则相同。</li><li>函数的参数放在一对圆括号内，参数可以是一个，多个或零个，参数之间必须通过逗号间隔，这种参数称为形式参数。</li><li>括号后面以冒号结尾，冒号的下面就是函数的主体。</li><li>返回值不是必须的，return语句不是必须的</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def print_info():</span><br><span class="line">print(&#x27;我叫小薛,今年 18 岁，是一名大学生&#x27;)</span><br></pre></td></tr></table></figure><p>好了，我们已经定义了一个函数，那么接下来我们来完成函数的调用。</p><h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><p>函数的调用采用函数名加一对圆括号的方式，圆括号中的参数是传递给函数的具体值。函数调用的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(实参 1,实参 2…)</span><br></pre></td></tr></table></figure><p>注意：即使函数不需要参数，调用函数时候，也要在函数名后使用一对空的圆括号</p><p>例如：</p><pre><code>def print_info():    print(&#39;我叫小薛,今年 18 岁，是一名大学生&#39;)print_info()</code></pre><p>上述程序虽然达到了介绍效果，但是并不够灵活，如果想要在打印另一个人（李四）的个人信息，就需要去上面去修改源码，这样的话会非常麻烦的，因此在定义的时候可以让函数接收数据，这样的话就使程序变得比较灵活，就能达到想要的效果。</p><h4 id="函数的形参与实参"><a href="#函数的形参与实参" class="headerlink" title="函数的形参与实参"></a>函数的形参与实参</h4><p>下面实现，定义参数完成自我介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#定义函数 </span><br><span class="line">def print_info(name,age): </span><br><span class="line">    print(&#x27;我叫&#123;0&#125;,今年&#123;1&#125;岁，是一名大学生&#x27;.format(name,age))</span><br><span class="line"></span><br><span class="line">#调用函数 </span><br><span class="line">print_info(&#x27;李四&#x27;,19)</span><br></pre></td></tr></table></figure><p>在上面的程序中，name 和 age 称为“形式参数”，简称“形参”。在调用函数printInfo(‘李四’,19)时，传递的’李四’和 19 称为“实际参数”，简称“实参”。</p><h4 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h4><p>函数的返回使用 return 语句，return 的后面可以是变量或者表达式。</p><p>例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#定义函数计算两数之和 </span><br><span class="line">def add(a,b): </span><br><span class="line">    return a+b </span><br><span class="line">#调用函数 </span><br><span class="line">sum=add(20,30) </span><br><span class="line">print(&#x27;两数的和:&#x27;,sum)</span><br></pre></td></tr></table></figure><p>通过函数参数传入斐波那切数列长度，使用 return 语句返回计算结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#通过函数参数传入斐波那切数列长度，使用 return 语句返回计算结果</span><br><span class="line">#定义函数</span><br><span class="line">def fibs(n): #n 代码斐波那切数列的长度</span><br><span class="line">    #定义斐波那切数列的初识列表 </span><br><span class="line">    result=[0,1]</span><br><span class="line">#通过循环计算，将结果添加到列表中 </span><br><span class="line">    for x in range(n-2): </span><br><span class="line">        result.append(result[-1]+result[-2]) </span><br><span class="line">    #将计算结果返回 </span><br><span class="line">    return result </span><br><span class="line">#调用函数 </span><br><span class="line">re=fibs(10) </span><br><span class="line">print(&#x27;斐波那切数列:&#x27;,re)</span><br></pre></td></tr></table></figure><h4 id="文档注释-docstring"><a href="#文档注释-docstring" class="headerlink" title="文档注释-docstring"></a>文档注释-docstring</h4><p>注释尽管在程序中不是必需的，但却是必要的。如果没有注释，那么程序就很难被别人读懂，甚至过段时间，自己都看不明白自己编写的程序。</p><p>而对于函数来说，还可以使用另外一种注释：文档注释（docstring），也有人成为“函数的注释”。文档注释，需要在函数头(包含 def 关键字的那一行)的下一行用三个单引号或者三个双引号来实现，中间可以加入多行文字进行说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def add(a,b): </span><br><span class="line">&quot;&quot;&quot;定义函数计算两数之和 &quot;&quot;&quot;</span><br><span class="line">    return a+b </span><br><span class="line">#调用函数 </span><br><span class="line">sum=add(20,30) </span><br><span class="line">print(&#x27;两数的和:&#x27;,sum)</span><br></pre></td></tr></table></figure><h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><h5 id="位置传参"><a href="#位置传参" class="headerlink" title="位置传参"></a>位置传参</h5><p>函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fun1(a,b,c): </span><br><span class="line">    print(a,b,c) </span><br><span class="line"></span><br><span class="line">fun1(2,3,4) </span><br><span class="line">fun1(3,4) #报错，位置传参不匹配</span><br></pre></td></tr></table></figure><h5 id="默认传参（可选参数）"><a href="#默认传参（可选参数）" class="headerlink" title="默认传参（可选参数）"></a>默认传参（可选参数）</h5><p>在声明函数时，预先为参数设置一个默认值，当调用函数时，如果某个参数有了默认值，则可以不用向函数传递该参数，此时，函数将使用默认值作为该参数进行运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def fun1(a,b,c=10,d=20): </span><br><span class="line">    print(a,b,c,d) </span><br><span class="line"></span><br><span class="line">fun1(8,9)  #参数 c 和 d 使用默认值 </span><br><span class="line">fun1(8,9,19) #参数 d 使用默认值 </span><br><span class="line">fun1(8,9,19,29)</span><br></pre></td></tr></table></figure><h5 id="关键字传参"><a href="#关键字传参" class="headerlink" title="关键字传参"></a>关键字传参</h5><p>当我们忘记形参顺序时，我们也可以通过形参的名称传递参数。当使用通过形参的名称传递参数的时候，要将所有必传参数赋值，赋值的顺序可以不必按照函数声明时的参数顺序进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fun1(a,b,c): </span><br><span class="line">    print(a,b,c) </span><br><span class="line">    </span><br><span class="line">fun1(8,9,19) #位置传参 </span><br><span class="line">fun1(c=10, a=20, b=30) #命名传参，参数顺序可以和声明时的顺序不一致</span><br></pre></td></tr></table></figure><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>声明函数时，如果在参数名前加上一个星号“*”，则表示将多个参数收集到一个“元组”对象中；如果在参数名前加上两个星“**”，则表示将多个参数收集到一个“字典”对象中。当然可变参数要放在最后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def fun1(a,b,*c): #函数参数前添加一个&quot;*&quot;,可变参数以元组形式体现 </span><br><span class="line">    print(a,b,c) </span><br><span class="line">fun1(8,9,19,20) </span><br><span class="line"></span><br><span class="line">def fun2(a,b,**c): #函数参数前添加两个&quot;**&quot;,可变参数以字典形式体现 </span><br><span class="line">    print(a,b,c) </span><br><span class="line">fun2(8,9,name=&#x27;gaoqi&#x27;,age=18) </span><br><span class="line"></span><br><span class="line">def fun3(a,b,*c,**d): </span><br><span class="line">    print(a,b,c,d) </span><br><span class="line"></span><br><span class="line">fun3(8,9,20,30,name=&#x27;gaoqi&#x27;,age=18)</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>可以将函数作为对象传递的函数叫做高阶函数。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map()函数接收两个参数，一个是函数(必须是一个参数的)，一个是序列，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的迭代器返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 对数列里的每个数字进行平方（返回迭代器）</span><br><span class="line">a = map(lambda x: x ** 2, [1, 2, 3, 4, 5])</span><br><span class="line">print(a)</span><br><span class="line">&lt;map object at 0x000001C1CDF31F40&gt;</span><br><span class="line"></span><br><span class="line">print(list(a))</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 也可以完成将数字列表转字符串列表</span><br><span class="line">s = map(str, [1, 2, 3, 4, 5])</span><br><span class="line">print(list(s))</span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce 将一个函数（必须是接收两个参数的）作用在一个序列上，把结果继续和序列的下一个元素做累积计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">lst=[1,2,3,4]</span><br><span class="line">print(reduce(lambda x,y: x*y+1, lst)) # 运行为41</span><br><span class="line"></span><br><span class="line">#可以传入可选参数（初始参数）</span><br><span class="line">lst=[1,2,3,4]</span><br><span class="line">print(reduce(lambda x,y: x*y+1, lst，3)) # 运行为113</span><br></pre></td></tr></table></figure><p>注意：Python3.x reduce() 已经被移到 functools 模块里，如果我们要使用，需要引入 functools 模块来调用 reduce() 函数。</p><p>有初始值时，开始两个参数为初始值和序列第一个元素，没有初始值的时候，开始两个参数为序列第一个元素和第二个元素。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter函数用于过滤序列。和 map函数类似，filter也接收一个函数和一个序列。但filter的作用是把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在一个 list 中，删掉偶数，只保留奇数 </span><br><span class="line">def is_odd(n): </span><br><span class="line">    return n % 2 == 1 </span><br><span class="line">L = filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])</span><br><span class="line">print(L)</span><br><span class="line">print(list(L))</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>sorted函数完成排序功能，它接受一个序列来进行对其排序，还可以接收reverse参数和一个 key 函数来实现自定义的排序，返回一个新的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sorter2 = sorted([1,3,6,-20,-70],key=abs) </span><br><span class="line">print(&quot;自定义排序:&quot;,sorter2) </span><br><span class="line"></span><br><span class="line">sorter2 = sorted([1,3,6,-20,-70],key=abs,reverse=True) </span><br><span class="line">print(&quot;自定义反向排序:&quot;,sorter2) </span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>不需要显式定义的函数叫做匿名函数，这样就避免了函数名冲突，精简了代码。</p><p>lambda 表达式就是一个简单的函数。使用 lambda 声明的函数可以返回一个值，在调用函数时，直接使用 lambda 表达式的返回值。语法格式如下：</p><p><code>lambda arg1,arg2,arg3... : &lt;表达式&gt;</code></p><p>其中 arg1/arg2/arg3 为函数的参数。&lt;表达式&gt;相当于函数体，返回结果是表达式的运算结果。这就使得匿名函数只能计算并返回一个表达式的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = lambda a,b,c:a+b+c </span><br><span class="line">print(&#x27;2+3+4 的结果:&#x27;,f(2,3,4))</span><br><span class="line"></span><br><span class="line">L=map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]) </span><br><span class="line">print(list(L))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h3&gt;&lt;p&gt;函数可重复使用，用来实现相关联功能的代码段。函数能提高程序的模块性、代码的重复利用率。Python函数分两类，即内建函数，自</summary>
      
    
    
    
    
    <category term="python基础" scheme="https://xiaowog.top/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://xiaowog.top/2022/02/20/02.20-%E9%9B%86%E5%90%88/"/>
    <id>https://xiaowog.top/2022/02/20/02.20-%E9%9B%86%E5%90%88/</id>
    <published>2022-02-20T05:04:20.000Z</published>
    <updated>2022-04-02T15:50:17.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。注意集合是<strong>无序</strong>的。</p><h4 id="集合创建"><a href="#集合创建" class="headerlink" title="集合创建"></a>集合创建</h4><h5 id="使用-创建集合对象"><a href="#使用-创建集合对象" class="headerlink" title="使用{}创建集合对象"></a>使用{}创建集合对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;3,5,7&#125; #集合存储整数 </span><br><span class="line">b=&#123;&#x27;hello&#x27;,&#x27;python&#x27;&#125; #集合存储字符串 </span><br><span class="line">c=&#123;3,4,True,&#x27;abc&#x27;,56.4&#125; #集合存储不同类型的数据 </span><br><span class="line">print(a) </span><br><span class="line">print(b) </span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h5 id="使用-set-创建集合对象"><a href="#使用-set-创建集合对象" class="headerlink" title="使用 set()创建集合对象"></a>使用 set()创建集合对象</h5><p>可以使用set()创建空集合，但不能使用{}创建，因为{}它创建的是字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;b&#x27;]</span><br><span class="line">b=set(a) #将列表转换为集合</span><br><span class="line">print(b)</span><br><span class="line">c=(1,2,3,4,5) </span><br><span class="line">d=set(c) #将元组转换为集合 </span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><h5 id="使用推导式创建集合对象"><a href="#使用推导式创建集合对象" class="headerlink" title="使用推导式创建集合对象"></a>使用推导式创建集合对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0&#125; #推导式也可以用于推导集合</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;3,5,7&#125; </span><br><span class="line">a.add(&#x27;hello&#x27;) #add 方法添加元素 </span><br><span class="line">print(a)</span><br><span class="line">a.update([11, 17])</span><br><span class="line">a.update(&#x27;world&#x27;) #update会把元素拆分再添加进去</span><br></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>使用 remove()，discard()实现集合删除指定元素、pop()实现删除并返回指定元素，clear()清空整个集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;10,20,30,40,50&#125; </span><br><span class="line">a.remove(20) #删除集合中的元素，如果没有则报错</span><br><span class="line">print(a) </span><br><span class="line">a.discard(30)</span><br><span class="line">print(a) </span><br><span class="line">print(a.pop())</span><br><span class="line">a.clear() #将集合清空 </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h4 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h4><p>像数学中概念一样，Python 对集合也提供了并集、交集、差集等运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1,3,&#x27;sxt&#x27;&#125; </span><br><span class="line">b = &#123;&#x27;he&#x27;,&#x27;it&#x27;,&#x27;sxt&#x27;&#125; </span><br><span class="line">print(&#x27;并集：&#x27;,a|b) #并集 </span><br><span class="line">print(&#x27;并集：&#x27;,a.union(b))#并集 </span><br><span class="line">print(&#x27;交集：&#x27;,a&amp;b) #交集 </span><br><span class="line">print(&#x27;交集：&#x27;,a.intersection(b)) #交集 </span><br><span class="line">print(&#x27;差集：&#x27;,a-b) #差集 </span><br><span class="line">print(&#x27;差集：&#x27;,a.difference(b)) #差集</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;集合（set）&quot;&gt;&lt;a href=&quot;#集合（set）&quot; class=&quot;headerlink&quot; title=&quot;集合（set）&quot;&gt;&lt;/a&gt;集合（set）&lt;/h3&gt;&lt;p&gt;Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。注</summary>
      
    
    
    
    
    <category term="python基础" scheme="https://xiaowog.top/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>字典</title>
    <link href="https://xiaowog.top/2022/02/17/02.17-%E5%AD%97%E5%85%B8/"/>
    <id>https://xiaowog.top/2022/02/17/02.17-%E5%AD%97%E5%85%B8/</id>
    <published>2022-02-17T11:48:37.000Z</published>
    <updated>2022-04-02T16:27:59.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Python 内置了字典(dict)的支持，使用键-值（key-value）存储，具有极快的查找速度。字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值对(key=&gt;value)用冒号(:)分割，每对之间用逗号(,)分割，整个字典包括在花括号({})中 ，语法格式如下： </p><p><code>d = &#123;key1 : value1, key2 : value2 &#125;</code></p><p>字典中通过“键对象”找到对应的“值对象”。<strong>“键”是任意的不可变数据</strong>，比如：整数、浮点数、字符串、元组。但是：列表、字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。“值”可以是任意的数据，并且可重复。</p><p>注意：字典是<strong>无序</strong>可变序列</p><h4 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h4><h5 id="通过-，dict-创建"><a href="#通过-，dict-创建" class="headerlink" title="通过{}，dict()创建"></a>通过{}，dict()创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">b = dict(name=&#x27;xiaoxue&#x27;,age=18,job=&#x27;programmer&#x27;) </span><br><span class="line">c = dict([(&quot;name&quot;,&quot;xiaoxue&quot;),(&quot;age&quot;,18),(&quot;job&quot;,&#x27;programmer&#x27;)]) </span><br><span class="line">d = &#123;&#125; #空的字典对象 </span><br><span class="line">e = dict() #空的字典对象 </span><br><span class="line">print(&#x27;字典 a：&#x27;,a) </span><br><span class="line">print(&#x27;字典 b：&#x27;,b)</span><br><span class="line">print(&#x27;字典 c：&#x27;,c)</span><br><span class="line">print(&#x27;字典 d：&#x27;,d) </span><br><span class="line">print(&#x27;字典 e：&#x27;,e)</span><br></pre></td></tr></table></figure><h5 id="通过zip-创建"><a href="#通过zip-创建" class="headerlink" title="通过zip()创建"></a>通过zip()创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;job&#x27;]</span><br><span class="line">v = [&#x27;xiaoxue&#x27;,18,&#x27;teacher&#x27;]</span><br><span class="line">a = dict(zip(k,v))</span><br><span class="line">print(&#x27;字典 a：&#x27;,a)</span><br></pre></td></tr></table></figure><h5 id="通过-fromkeys-创建值为空的字典"><a href="#通过-fromkeys-创建值为空的字典" class="headerlink" title="通过 fromkeys 创建值为空的字典"></a>通过 fromkeys 创建值为空的字典</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = dict.formkeys([&#x27;name&#x27;,&#x27;age&#x27;,&#x27;job&#x27;])</span><br><span class="line">print(&#x27;值为空的字典 a:&#x27;,a)</span><br></pre></td></tr></table></figure><h5 id="推导式语法创建"><a href="#推导式语法创建" class="headerlink" title="推导式语法创建"></a>推导式语法创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items3 = &#123;num: num ** 2 for num in range(1, 10)&#125;</span><br><span class="line">print(items3)</span><br></pre></td></tr></table></figure><h4 id="字典的访问"><a href="#字典的访问" class="headerlink" title="字典的访问"></a>字典的访问</h4><h5 id="通过-键-访问"><a href="#通过-键-访问" class="headerlink" title="通过 [键] 访问"></a>通过 [键] 访问</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">print(&#x27;name:&#x27;,a[&#x27;name&#x27;]) </span><br><span class="line">print(&#x27;age:&#x27;,a[&#x27;age&#x27;]) </span><br><span class="line">print(&#x27;job:&#x27;,a[&#x27;job&#x27;])</span><br></pre></td></tr></table></figure><p>注意：若键不存在，则抛出异常 </p><h5 id="通过get-方法访问"><a href="#通过get-方法访问" class="headerlink" title="通过get 方法访问"></a>通过get 方法访问</h5><p>优点是：指定键不存在，返回 None；<strong>也可以设定指定键不存在时默认返回的对象</strong>。推荐使用 get()获取“值对象”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">print(&#x27;name:&#x27;,a.get(&#x27;name&#x27;)) </span><br><span class="line">print(&#x27;age:&#x27;,a.get(&#x27;age&#x27;)) </span><br><span class="line">print(&#x27;job:&#x27;,a.get(&#x27;job&#x27;)) </span><br><span class="line">print(&#x27;family&#x27;,a.get(&#x27;family&#x27;))</span><br><span class="line">print(&#x27;sex:&#x27;,a.get(&#x27;sex&#x27;，&#x27;man&#x27;))</span><br></pre></td></tr></table></figure><h5 id="对字典中所有键值对进行遍历"><a href="#对字典中所有键值对进行遍历" class="headerlink" title="对字典中所有键值对进行遍历"></a>对字典中所有键值对进行遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">for i in a:</span><br><span class="line">print(f&#x27;&#123;key&#125;:&#123;a[key]&#125;&#x27;)</span><br></pre></td></tr></table></figure><h4 id="字典的常见操作"><a href="#字典的常见操作" class="headerlink" title="字典的常见操作"></a>字典的常见操作</h4><p>字典类似于列表，也可以进行增删改查等操作。就像其他内建类型一样，字典也有方法，这些方法非常有用。</p><h5 id="通过键修改创建"><a href="#通过键修改创建" class="headerlink" title="通过键修改创建"></a>通过键修改创建</h5><p> 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在，则新增“键值对”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">a[&#x27;address&#x27;]=&#x27;北京&#x27; #address 的键不存在，则新增 </span><br><span class="line">a[&#x27;age&#x27;]=28 #age 的键存在，则进行修改 </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="通过update方法进行修改"><a href="#通过update方法进行修改" class="headerlink" title="通过update方法进行修改"></a>通过update方法进行修改</h5><p> update 方法可以用一个字典中的元素更新另外一个字典。该方法接收一个参数。该参数表示用作更新数据的字典数据源。如果 key 有重复，则直接覆盖。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">b = &#123;&#x27;name&#x27;:&#x27;xuefengliu&#x27;,&#x27;money&#x27;:1000,&#x27;sex&#x27;:&#x27;男的&#x27;&#125; </span><br><span class="line">a.update(b) </span><br><span class="line">print(a) </span><br><span class="line"># 输出为&#123;&#x27;name&#x27;:&#x27;xuefengliu&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;，&#x27;money&#x27;:1000,&#x27;sex&#x27;:&#x27;男的&#x27;&#125; </span><br></pre></td></tr></table></figure><h5 id="字典元素的删除"><a href="#字典元素的删除" class="headerlink" title="字典元素的删除"></a>字典元素的删除</h5><p>字典中元素的删除，可以使用 del()方法；或者 clear()删除所有键值对；pop()删除指定键值对，并返回对应的“值对象”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">del(a[&#x27;name&#x27;]) #del 删除元素 </span><br><span class="line">print(a) </span><br><span class="line">b=a.pop(&#x27;age&#x27;) #pop 删除元素，返回对应的值 </span><br><span class="line">print(b) </span><br><span class="line">print(a) </span><br><span class="line">a.clear() #清空字典元素 </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>popitem()方法用于随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元素、最后一个元素的概念；popitem 弹出随机的项，因为字典并没有”最后的元素”或者其他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先获取键的列表）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">while len(a):</span><br><span class="line">    b = a.popitem()</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line"># print(a.popitem()) </span><br><span class="line"># print(a.popitem()) </span><br><span class="line"># print(a.popitem())</span><br></pre></td></tr></table></figure><h5 id="items-方法、keys-方法和-values-方法"><a href="#items-方法、keys-方法和-values-方法" class="headerlink" title="items 方法、keys 方法和 values 方法"></a>items 方法、keys 方法和 values 方法</h5><p>items 方法用于返回字典中所有的 key-value 对。获得的每一个 key-value 对用一个元组表示。items 方法返回的值是一个被称为字典视图的特殊类型，可以被用于迭代（如使用在for 循环中）。items 方法的返回值与字典使用了同样的值，也就是说，修改了字典或 items方法的返回值，修改的结果就会反应在另一方法上。keys 方法用于返回字典中所有的 key，返回值类型与 items 方法类似，可以用于迭代。values 方法用于以迭代器形式返回字典中值的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;name&#x27;:&#x27;xiaoxue&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; </span><br><span class="line">print(a.items()) #字典中所有的 key-value 对 </span><br><span class="line">print(a.keys()) #字典中所有的 keys </span><br><span class="line">print(a.values()) #字典中所有的 value </span><br><span class="line">#通过遍历 key，根据 key 获取值 </span><br><span class="line">for key in a.keys(): </span><br><span class="line">    print(key,&#x27;:&#x27;,a.get(key))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h3&gt;&lt;p&gt;Python 内置了字典(dict)的支持，使用键-值（key-value）存储，具有极快的查找速度。字典是另一种可变容器模型，且可存储任意</summary>
      
    
    
    
    
    <category term="python基础" scheme="https://xiaowog.top/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>元组</title>
    <link href="https://xiaowog.top/2022/02/14/02.14-%E5%85%83%E7%BB%84/"/>
    <id>https://xiaowog.top/2022/02/14/02.14-%E5%85%83%E7%BB%84/</id>
    <published>2022-02-14T13:24:53.000Z</published>
    <updated>2022-04-02T15:36:26.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组和列表一样，也是一种<strong>有序</strong>序列。但元组的元素不能修改，所以一些操作的效率要比列表高。</p><h4 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a>元组的创建</h4><h5 id="最基本的创建"><a href="#最基本的创建" class="headerlink" title="最基本的创建"></a>最基本的创建</h5><p>通过()创建元组，小括号可以省略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=1,2,3,4,5,6,7 #创建一个元组 省略了括号 </span><br><span class="line">b=(1,2,3,4,5,6,7) #创建一个元组 </span><br><span class="line">c=(42,) #创建一个只有一个元素值的元组 </span><br><span class="line">d=() #创建一个空的元组 </span><br><span class="line">print(a) </span><br><span class="line">print(b) </span><br><span class="line">print(c)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><h5 id="通过-tuple-创建元组"><a href="#通过-tuple-创建元组" class="headerlink" title="通过 tuple()创建元组"></a>通过 tuple()创建元组</h5><p>tuple 函数的功能与 list 函数基本上是一样的。以一个序列作为参数并把它转换为元祖。如果元素的参数就是元祖，那么该参数就会被原样返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#使用 tuple()函数创建元组 </span><br><span class="line">a=tuple(&quot;abc&quot;) </span><br><span class="line">b=tuple(range(3)) </span><br><span class="line">c=tuple((1,2,3,4,5)) </span><br><span class="line">d = tuple() # 创建空元组</span><br><span class="line">print(a) </span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h5 id="元组的基本操作"><a href="#元组的基本操作" class="headerlink" title="元组的基本操作"></a>元组的基本操作</h5><p>元组的元素不能修改，但可以转换成列表进行修改元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = (20,10,30,9,8) </span><br><span class="line">a[3]=33 #修改元组中的元素，报错</span><br><span class="line">a = list(a)</span><br><span class="line">a[3]=33 #修改成功</span><br><span class="line">print(a) #输出为[20,10,33,9,8]</span><br></pre></td></tr></table></figure><p>元组中的元素不可变，可能只是元素的id地址不可变，如元组中的列表中的元素。</p><h5 id="zip创建"><a href="#zip创建" class="headerlink" title="zip创建"></a>zip创建</h5><p>zip(列表 1，列表 2，…)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [10,20,30] </span><br><span class="line">b = [40,50,60] </span><br><span class="line">c = [70,80,90] </span><br><span class="line">d = zip(a,b,c) </span><br><span class="line">print(tuple(d))</span><br></pre></td></tr></table></figure><h5 id="生成器推导式创建元组"><a href="#生成器推导式创建元组" class="headerlink" title="生成器推导式创建元组"></a>生成器推导式创建元组</h5><p>从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。通过生成器对象，转化成列表或者元组。</p><p>也可以使用生成器对象的<code>__next__()</code>方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 请注意下面的代码创建的不是一个元组而是一个生成器对象</span><br><span class="line"># 通过生成器可以获取到数据但它不占用额外的空间存储数据</span><br><span class="line"># 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span><br><span class="line">import sys</span><br><span class="line">f = (x ** 2 for x in range(1, 1000))</span><br><span class="line">print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间</span><br><span class="line">print(f) #生成器对象 </span><br><span class="line">for val in f:</span><br><span class="line">    print(val) # 访问完成需要再次创建</span><br><span class="line">print(list(f)) #空列表</span><br><span class="line"></span><br><span class="line">s = (x*2 for x in range(5)) </span><br><span class="line">print(tuple(s)) #tuple 函数转换为元组</span><br><span class="line"></span><br><span class="line">s = (x*2 for x in range(5))</span><br><span class="line">print(&#x27;next 方法获取元素：&#x27;,s.__next__()) </span><br><span class="line">print(&#x27;next 方法获取元素：&#x27;,s.__next__()) </span><br><span class="line">print(&#x27;next 方法获取元素：&#x27;,s.__next__())</span><br></pre></td></tr></table></figure><h4 id="元组的访问"><a href="#元组的访问" class="headerlink" title="元组的访问"></a>元组的访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = (20,10,30,9,8) </span><br><span class="line">print(a[1]) </span><br><span class="line">print(a[1:3]) </span><br><span class="line">print(a[:4])</span><br><span class="line">for i in a:</span><br><span class="line">print(i) #元组遍历</span><br></pre></td></tr></table></figure><p>列表关于排序的方法 list.sort()是修改原列表对象，元组没有该方法。如果要对元组排序，只能使用内置函数 sorted(tupleObj)，并生成新的列表对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = (20,10,30,9,8) </span><br><span class="line">print(sorted(a))</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>元组在创建时间和占用的空间上面都优于列表。</p><p>如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个函数要返回多个值，使用元组也是不错的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;元组&quot;&gt;&lt;a href=&quot;#元组&quot; class=&quot;headerlink&quot; title=&quot;元组&quot;&gt;&lt;/a&gt;元组&lt;/h3&gt;&lt;p&gt;元组和列表一样，也是一种&lt;strong&gt;有序&lt;/strong&gt;序列。但元组的元素不能修改，所以一些操作的效率要比列表高。&lt;/p&gt;
&lt;h4 i</summary>
      
    
    
    
    
    <category term="python基础" scheme="https://xiaowog.top/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>列表</title>
    <link href="https://xiaowog.top/2022/02/11/02.11-%E5%88%97%E8%A1%A8/"/>
    <id>https://xiaowog.top/2022/02/11/02.11-%E5%88%97%E8%A1%A8/</id>
    <published>2022-02-11T07:24:46.000Z</published>
    <updated>2022-04-02T08:26:48.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表用于存储任意数目、任意类型的数据集合。在 Python 中，用方括号 [] 来表示列表，并用逗号来分隔其中的元素。语法格式如下：</p><p><code>list=[元素 1,元素 2,…]</code> </p><h4 id="列表创建"><a href="#列表创建" class="headerlink" title="列表创建"></a>列表创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a1 = []  # 创建一个空列表</span><br><span class="line">a2 = list() #创建一个空列表</span><br><span class="line">b = [1,2,3,4]  # 创建一个整数类型的列表</span><br><span class="line">c = [10,20,&#x27;abc&#x27;,True,3.14]  # 创建不同类型的列表</span><br><span class="line"># 乘号表示列表元素的重复</span><br><span class="line">e = [&#x27;hello&#x27;] * 3</span><br><span class="line">print(e)  # 输出结果为[&#x27;hello&#x27;,&#x27;hello&#x27;,&#x27;hello&#x27;]</span><br></pre></td></tr></table></figure><h5 id="list-创建列表"><a href="#list-创建列表" class="headerlink" title="list()创建列表"></a>list()创建列表</h5><p>list()可以将任何可迭代对象转化成列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = list(&quot;gaoqi,sxt&quot;) </span><br><span class="line">print(d)  # 输出结果为[&#x27;g&#x27;,&#x27;a&#x27;,&#x27;o&#x27;,&#x27;q&#x27;,&#x27;i&#x27;,&#x27;,&#x27;,&#x27;s&#x27;,&#x27;x&#x27;,&#x27;t&#x27;]</span><br></pre></td></tr></table></figure><h5 id="range-创建整数列表"><a href="#range-创建整数列表" class="headerlink" title="range()创建整数列表"></a>range()创建整数列表</h5><p>注意range()函数和2.x版本中产生的对象类型不同，3.x版本创建的是可迭代对象，而不是列表，使用我们可以使用list()函数进行类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = list(range(10))</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="推导式生成列表-列表生成式"><a href="#推导式生成列表-列表生成式" class="headerlink" title="推导式生成列表 (列表生成式)"></a>推导式生成列表 (列表生成式)</h5><p>使用列表推导式可以非常方便的创建列表，语法如下:</p><p><code>[表达式  for item in 可迭代对象 ]</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=[x for x in range(1,5)]</span><br><span class="line">b=[x*2 for x in range(1,5)]</span><br><span class="line">c=[x*2 for x in range(1,20) if x%5==0 ] #增加条件筛选，5的倍数</span><br><span class="line">d=[x for x in &quot;abcdefg&quot;]</span><br><span class="line"></span><br><span class="line">print(&quot;a 列表的元素:&quot;,a)</span><br><span class="line">print(&quot;b 列表的元素:&quot;,b)</span><br><span class="line">print(&quot;c 列表的元素:&quot;,c)</span><br><span class="line">print(&quot;d 列表的元素:&quot;,d)</span><br></pre></td></tr></table></figure><h4 id="列表的基本操作"><a href="#列表的基本操作" class="headerlink" title="列表的基本操作"></a>列表的基本操作</h4><p>列表中有一些自己的操作例如列表增加、列表修改、列表删除。当列表增加和删除元素时，会有列表元素的大量移动，效率较低。除非必要，一般只在列表的尾部添加元素或删除元素，这会大大提高列表的操作效率。</p><h5 id="列表的查找"><a href="#列表的查找" class="headerlink" title="列表的查找"></a>列表的查找</h5><h6 id="通过索引直接访问元素"><a href="#通过索引直接访问元素" class="headerlink" title="通过索引直接访问元素"></a>通过索引直接访问元素</h6><p>序列中的所有元素都是有索引的，编号从 0 开始递增，最大到列表的长度减 1。序列中的所有元素都可以通过索引访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [10,20,30,40,50,60,70,80,90] </span><br><span class="line">print(&quot;列表中的第一个元素:&quot;,a[0]) </span><br><span class="line">print(&quot;列表中的第三个元素：&quot;,a[2])</span><br></pre></td></tr></table></figure><p>如果索引是负数，那么 Python 语言会从列表右侧第一个元素开始获取。序列最后一个元素的索引是-1，倒数第二个元素的索引是-2，以此类推。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [10,20,30,40,50,60,70,80,90]</span><br><span class="line">print(&quot;列表中倒数第一个元素:&quot;,a[-1])</span><br><span class="line">print(&quot;列表中倒数第三个元素：&quot;,a[-3])</span><br></pre></td></tr></table></figure><p>当索引超过列表的索引范围，会抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [10,20,30,40,50,60,70,80,90] </span><br><span class="line">#列表中有 9 个元素从左侧获取的索引范围：[0 到 8] </span><br><span class="line">#列表中有 9 个元素从右侧获取的索引范围：[-1 到-9] </span><br><span class="line">print(a[-9]) </span><br><span class="line">print(a[0]) </span><br><span class="line">print(a[9]) #超出范围</span><br></pre></td></tr></table></figure><h6 id="index-查找"><a href="#index-查找" class="headerlink" title="index()查找"></a>index()查找</h6><p>index()可以获取指定元素首次出现的索引位置。语法是：</p><p><code>index(value,[start,[end]])</code></p><p>其中，start 和 end 指定了搜索的范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [10,20,30,40,50,20,30,20,30] </span><br><span class="line">print(a.index(20)) #从列表中搜索第一个 20 </span><br><span class="line">print(a.index(20,3)) #从索引位置 3 开始往后搜索的第一个 20</span><br><span class="line">print(a.index(30,5,7)) #从索引位置 5 到 7 (不包含)这个区间，第一次出现 30 元素的位置</span><br></pre></td></tr></table></figure><h6 id="列表的切片"><a href="#列表的切片" class="headerlink" title="列表的切片"></a>列表的切片</h6><p>和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的<strong>复制</strong>或者将列表中的一部分取出来创建出新的列表，代码如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fruits =[&#x27;grape&#x27;, &#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;waxberry&#x27;, ‘pitaya&#x27;, &#x27;pear&#x27;, &#x27;mango&#x27;]</span><br><span class="line"></span><br><span class="line"># 列表切片</span><br><span class="line">fruits2 = fruits[1:4]</span><br><span class="line">print(fruits2) # apple strawberry waxberry</span><br><span class="line"></span><br><span class="line"># 可以通过完整切片操作来复制列表</span><br><span class="line">fruits3 = fruits[:]</span><br><span class="line">print(fruits3)</span><br><span class="line"></span><br><span class="line">fruits4 = fruits[-3:-1]</span><br><span class="line">print(fruits4) # [&#x27;pitaya&#x27;, &#x27;pear&#x27;]</span><br><span class="line"></span><br><span class="line"># 可以通过反向切片操作来获得倒转后的列表的拷贝</span><br><span class="line">fruits5 = fruits[::-1]</span><br><span class="line">print(fruits5) # [&#x27;mango&#x27;, &#x27;pear&#x27;, &#x27;pitaya&#x27;, &#x27;waxberry&#x27;, &#x27;strawberry&#x27;, &#x27;apple&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure><h6 id="for循环遍历列表"><a href="#for循环遍历列表" class="headerlink" title="for循环遍历列表"></a>for循环遍历列表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 通过循环用下标遍历列表元素</span><br><span class="line">for index in range(len(list1)):</span><br><span class="line">    print(list1[index])</span><br><span class="line"># 通过for循环遍历列表元素</span><br><span class="line">for elem in list1:</span><br><span class="line">    print(elem)</span><br><span class="line"># 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值</span><br><span class="line">for index, elem in enumerate(list1):</span><br><span class="line">    print(index, elem)</span><br></pre></td></tr></table></figure><h5 id="列表的修改"><a href="#列表的修改" class="headerlink" title="列表的修改"></a>列表的修改</h5><p>修改列表中的某一个元素，可以像使用数组一样对列表中的特定元素赋值，也就是使用一对中括号指定元素在列表中的索引，然后使用赋值运算符（=）进行赋值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=[&#x27;admin&#x27;,&#x27;lili&#x27;,&#x27;john&#x27;] </span><br><span class="line">s[0]=&#x27;管理员&#x27; </span><br><span class="line">print(&#x27;修改后列表的元素：&#x27;,s)</span><br></pre></td></tr></table></figure><h5 id="列表的添加"><a href="#列表的添加" class="headerlink" title="列表的添加"></a>列表的添加</h5><h6 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h6><p>在列表的末尾追加一个新对象，使用 append()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#列表中添加元素 </span><br><span class="line">a=[10,20,30] </span><br><span class="line">a.append(40) </span><br><span class="line">print(&#x27;增加元素后的列表：&#x27;,a)</span><br></pre></td></tr></table></figure><h6 id="列表加法"><a href="#列表加法" class="headerlink" title="列表加法"></a>列表加法</h6><p><code>+</code>运算符操作，并不是真正的尾部添加元素，而是创建新的列表对象；将原列表的元素和新列表的元素依次复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#列表使用+操作符相加 </span><br><span class="line">a=[10,20,30] </span><br><span class="line">print(&#x27;a 的地址：&#x27;,id(a)) </span><br><span class="line">b=[40,50] </span><br><span class="line">a=a+b </span><br><span class="line">print(&#x27;a 列表的元素：&#x27;,a) </span><br><span class="line">print(&#x27;a 的地址：&#x27;,id(a))</span><br><span class="line">#此处，变量 a 的地址发生了变化。也就是创建了新的列表对象。</span><br></pre></td></tr></table></figure><h6 id="extend"><a href="#extend" class="headerlink" title="extend()"></a>extend()</h6><p>extend()方法，将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#使用 extend()方法添加列表 </span><br><span class="line">a=[10,20,30] </span><br><span class="line">print(&#x27;a 的地址：&#x27;,id(a)) </span><br><span class="line">b=[40,50] </span><br><span class="line">a.extend(b) </span><br><span class="line">print(&#x27;a 列表的元素：&#x27;,a)  # [10,20,30,40,50]</span><br><span class="line">print(&#x27;a 的地址：&#x27;,id(a))</span><br></pre></td></tr></table></figure><h6 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h6><p>使用 insert()方法可以将指定的元素插入到列表对象的任意制定位置。这样会让插入位置后面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#使用 insert 函数插入元素 </span><br><span class="line">a=[10,20,30] </span><br><span class="line">a.insert(2,100) #在列表 a 的索引 2 处插入元素 100 </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>类似发生这种移动的函数还有：remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后面元素的移动。</p><h5 id="列表的删除"><a href="#列表的删除" class="headerlink" title="列表的删除"></a>列表的删除</h5><h6 id="del"><a href="#del" class="headerlink" title="del()"></a>del()</h6><p>del 删除列表指定位置的元素。语法格式：del 元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [1234,111,123]</span><br><span class="line">del a[0]</span><br></pre></td></tr></table></figure><h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p>从指定的位置删除元素并返回该元素,如果未指定位置则默认操作列表最后一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1234,111,123]</span><br><span class="line">c = a.pop(0)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h6 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h6><p>删除首次出现的指定元素，若不存在该元素抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1234,111,123]</span><br><span class="line">if 1234 in a:</span><br><span class="line">    a.remove(1234)</span><br></pre></td></tr></table></figure><h6 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h6><p>clear()用于清空列表内容 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[11,20,13,&#x27;a&#x27;,True,&#x27;hello&#x27;] </span><br><span class="line">a.clear() </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><h6 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h6><p>len方法返回的是列表的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[10,20,30,40,50,60] </span><br><span class="line">print(len(a)) #运行结果是 6 </span><br></pre></td></tr></table></figure><h6 id="max-min"><a href="#max-min" class="headerlink" title="max()   min()"></a>max()   min()</h6><p>max方法返回的是列表元素中的最大值，min方法返回的是列表元素中的最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=[10,20,30,40,50,60] </span><br><span class="line">print(max(a)) #运行结果是 60 </span><br><span class="line">print(min(a)) #运行结果是 10 </span><br><span class="line">b=[&#x27;a&#x27;,30,&#x27;b&#x27;,40] </span><br><span class="line">print(max(b)) #字符串和数字不能比较，将抛出异常</span><br></pre></td></tr></table></figure><h6 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h6><p>copy()进行复制列表 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aa=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] </span><br><span class="line">bb=aa.copy() </span><br><span class="line">print(aa) </span><br><span class="line">print(bb)</span><br></pre></td></tr></table></figure><h6 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h6><p>count()统计元素出现的次数 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[10,20,40,30,10,20,50,10] </span><br><span class="line">print(&#x27;元素 10 出现的次数：&#x27;,a.count(10)) </span><br><span class="line">print(&#x27;元素 20 出现的次数：&#x27;,a.count(20)) </span><br><span class="line">print(&#x27;元素 30 出现的次数：&#x27;,a.count(30))</span><br></pre></td></tr></table></figure><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p>reverse()用于将列表中的元素反向存放 ，原地操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2,3,4,5,6,7] </span><br><span class="line">a.reverse() </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h6 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h6><p>sorted（）函数，和sort（）方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#sort()用于对列表进行排序，调用该方法会改变原来的列表 </span><br><span class="line">a=[11,20,13,34,5,36,17] </span><br><span class="line">a.sort() </span><br><span class="line">print(a) </span><br><span class="line">print(&#x27;正序：&#x27;,a) </span><br><span class="line">a.sort(reverse=True) </span><br><span class="line">print(&#x27;逆序：&#x27;,a) </span><br><span class="line"></span><br><span class="line">#sorted 用于对列表进行排序，生成新列表，不改变原来的列表 </span><br><span class="line">print(&#x27;-&#x27;*5,&#x27;sorted 排序&#x27;,&#x27;-&#x27;*5) </span><br><span class="line">a=[11,20,13,34,5,36,17] </span><br><span class="line">b=sorted(a) </span><br><span class="line">print(&#x27;a 列表：&#x27;,a) #原来列表不会被修改 </span><br><span class="line">print(&#x27;正序 b 列表：&#x27;,b)</span><br><span class="line">b=sorted(a, reverse=True) </span><br><span class="line">print(&#x27;逆序 b 列表：&#x27;,b)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h3&gt;&lt;p&gt;列表用于存储任意数目、任意类型的数据集合。在 Python 中，用方括号 [] 来表示列表，并用逗号来分隔其中的元素。语法格式如下：&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="python基础" scheme="https://xiaowog.top/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python细节</title>
    <link href="https://xiaowog.top/2022/02/08/02.08-python%E7%BB%86%E8%8A%82/"/>
    <id>https://xiaowog.top/2022/02/08/02.08-python%E7%BB%86%E8%8A%82/</id>
    <published>2022-02-08T09:11:10.000Z</published>
    <updated>2022-07-20T07:17:33.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="for循环问题"><a href="#for循环问题" class="headerlink" title="for循环问题"></a>for循环问题</h3><p>​    每次进入循环前，都会判断当前循环次数与现在的可迭代对象的长度，如果小于，则进入循环，否则，循环结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss = [2,3,6,9,7,1]</span><br><span class="line">for i in ss:</span><br><span class="line">print(max(ss),end=&#x27;,&#x27;)</span><br><span class="line">ss.remove(max(ss))</span><br><span class="line"># 输出结果为9，7，6，</span><br></pre></td></tr></table></figure><p>​    这里，他只进行了三次循环，因为他第三次循环结束时可迭代对象为[2,3,1],长度为3等于循环次数，循环结束。更直观的例子如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [1,2,3,4]</span><br><span class="line">for i in s:</span><br><span class="line">print(s.pop(),end=&#x27;,&#x27;)  # pop()删除位于列表结尾的元素，并返回</span><br><span class="line"># 输出结果为4,3,</span><br></pre></td></tr></table></figure><h3 id="字典问题"><a href="#字典问题" class="headerlink" title="字典问题"></a>字典问题</h3><p>​    字典.items()返回的数据类型为特殊类型dict_items类型，可使用for循环遍历读取，读取出的形式为元组(‘键’,’值’)，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = &#123;&#x27;name&#x27;:&#x27;opus&#x27;,&#x27;age&#x27;:19,&#x27;job&#x27;:&#x27;teacher&#x27;&#125;</span><br><span class="line">print(p.items()) </span><br><span class="line"># 输出结果为dict_items([(&#x27;name&#x27;, &#x27;mill&#x27;), (&#x27;age&#x27;, 19), (&#x27;job&#x27;, &#x27;teacher&#x27;)])</span><br><span class="line"></span><br><span class="line">for i in p.items():</span><br><span class="line">print(i,end=&#x27;,&#x27;)  </span><br><span class="line"># 输出结果为(&#x27;name&#x27;, &#x27;mill&#x27;),(&#x27;age&#x27;, 19),(&#x27;job&#x27;, &#x27;teacher&#x27;), </span><br></pre></td></tr></table></figure><p>​    同样，字典.keys()返回的是dict_keys类型，字典.values()返回的是dict_values类型，此处就不一一举例了。</p><p>字典里的max和min方法比较的是键的大小，而不是值的大小，返回的同样是键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;&#x27;a&#x27;:9,&#x27;b&#x27;:8,&#x27;c&#x27;:7&#125;</span><br><span class="line">print(s.max(),s.min())</span><br><span class="line"># 输出结果为:c a</span><br></pre></td></tr></table></figure><p>字典的get方法：字典.get(‘键’，默认值),如果找不到该键，则返回默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;&#x27;a&#x27;:9,&#x27;b&#x27;:8,&#x27;c&#x27;:7&#125;</span><br><span class="line">print(d.get(a,1),d.get(s,2))</span><br><span class="line"># 输出结果为9 2</span><br></pre></td></tr></table></figure><h3 id="从用户输入中得到数字列表"><a href="#从用户输入中得到数字列表" class="headerlink" title="从用户输入中得到数字列表"></a>从用户输入中得到数字列表</h3><p>​    eval() 返回传入字符串的表达式的结果。就是说：将字符串当成有效的表达式 来求值 并 返回计算结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = 7</span><br><span class="line">eval( &#x27;3 * x&#x27; )</span><br><span class="line"># 输出结果为21</span><br><span class="line">eval(&#x27;pow(2,2)&#x27;)</span><br><span class="line"># 输出结果为4</span><br><span class="line">eval(&#x27;2 + 2&#x27;)</span><br><span class="line"># 输出结果为4</span><br><span class="line">ls = eval(input(&#x27;&#x27;)) # 如果输入3，5，3那么得到的就是一个数字列表</span><br></pre></td></tr></table></figure><p>​    eval函数就是实现list、dict、tuple与str之间的转化，同样str函数把list，dict，tuple转为为字符串</p><p>同样，spilt()分割字符串也可得到数字列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls = map(int,input(&#x27;&#x27;).split(&#x27;,&#x27;))</span><br><span class="line">#如果输入3，5，3那么得到的就是一个数字列表</span><br></pre></td></tr></table></figure><h3 id="print函数详解"><a href="#print函数详解" class="headerlink" title="print函数详解"></a>print函数详解</h3><p>print是我们在python中最常用的内置函数了，很容易的发现，它会在行末自动加上换行，如果不需要换行，则只需要传递给<code>print</code>一个参数<code>end=&#39;&#39;</code>，end表示打印内容以字符串结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#x27;asd&#x27;</span><br><span class="line">b = &#x27;zxc&#x27;</span><br><span class="line">print(a)</span><br><span class="line">print(a,end=&#x27;&#x27;)</span><br><span class="line"># sep参数表示依次打印中以什么间隔，默认为空格</span><br><span class="line">print(a,b,1，sep=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;for循环问题&quot;&gt;&lt;a href=&quot;#for循环问题&quot; class=&quot;headerlink&quot; title=&quot;for循环问题&quot;&gt;&lt;/a&gt;for循环问题&lt;/h3&gt;&lt;p&gt;​    每次进入循环前，都会判断当前循环次数与现在的可迭代对象的长度，如果小于，则进入循环，否则，</summary>
      
    
    
    
    
    <category term="python坑" scheme="https://xiaowog.top/tags/python%E5%9D%91/"/>
    
  </entry>
  
</feed>
